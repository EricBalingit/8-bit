/*!
	8-bit ver 0.4.0 alpha
	(c) 2013-2016 Epistemex
	www.epistemex.com
	Copyrighted. Preview version! No license given at this point.
*/

/**
 * @name 8-bit Context for HTML5 Canvas.
 * @copyright Copyright &copy; 2013-2016 Epistemex
 * @license TBA
 */

/**
 * Creates a new 8-bit context instance which handles all operations
 * with the canvas bitmap.
 *
 * @param {HTMLCanvasElement} canvas - Canvas element to use
 * @param {*} options - option object, empty literal as minimum
 * @param {*} [options.palette=Palettes.CBM64] - Palette to use. You can use custom palette files if you wish.
 * @constructor
 */
function _8bit(canvas, options) {

	"use strict";


	var me = this,

		w = isNum(options.width) ? options.width : canvas.dataset.width || 320,		// internal width
		h = isNum(options.height) ? options.height : canvas.dataset.height || 240,	// internal height

		_ctx = canvas.getContext("2d", {alpha: false}),					// display context

		intRender = new _8bit.Shaders.Pixelated(w, h, true),			// internal renders, take local composite mode
		tmpRender = new _8bit.Shaders.Pixelated(w, h),
		supportsAlpha = _8bit.utils.contextSupportAlphaOption(),

		stack,															// save/restore stack
		state,
		matrix,															// internal matrix
		iPath,															// internal path (first initialized in init)
		palette,

		styleDest = {
			stroke: 0,
			fill: 1,
			bg: 2
		},

		noop = function(){};


	if (!_ctx) return;
	canvas.__is8 = true;

	/*------------------------------------------------------------------

		Public properties

	------------------------------------------------------------------*/

	/**
	 * If true (default) only properties and methods 100% compatible with
	 * 2D canvas can be used. If false, the convenience methods such as
	 * line() etc. will become available, but will break compatibility
	 * with 2D context if you at one point want to switch back.
	 * @type {boolean}
	 */
	this.strict = true;

	/**
	 * Horizontal and vertical aspect ratios between display canvas and
	 * internal bitmap. You can use this to multiply your display scaled
	 * elements to get the internal bitmap coordinates, or use the inverse
	 * to go from internal bitmap to display coordinates.
	 *
	 * @type {{x: number, y: number}}
	 */
	this.aspect = {};

	def("canvas", function() {return intRender.canvas});
	def("displayCanvas", function() {return canvas});
	def("displayWidth", function(){return canvas.width});
	def("displayHeight", function(){return canvas.height});
	def("width", function(){return w});
	def("height", function(){return h});
	def("ctx", function() {return _ctx});

	def("globalAlpha", function() {return 1}, noop);
	def("globalCompositeOperation", function() {return intRender.ctx.globalCompositeOperation}, setCompMode);
	def("imageSmoothingEnabled", function() {return state.imageSmoothingEnabled}, function(s) {state.imageSmoothingEnabled = !!s});
	def("imageSmoothingQuality", function() {return state.imageSmoothingQuality}, function(s) {
		if (["low", "medium", "high"].indexOf(s) > -1) state.imageSmoothingQuality = s;
	});

	def("strokeStyle", function() {return state.styles[styleDest.stroke].original}, function(s) {setStyle(s, styleDest.stroke)});
	def("fillStyle", function() {return state.styles[styleDest.fill].original}, function(s) {setStyle(s, styleDest.fill)});
	def("bgStyle", function() {return state.styles[styleDest.bg].original}, function(s) {setStyle(s, styleDest.bg)});
	def("palette", function() {return palette}, setPalette);

	def("lineWidth", function() {return state.lineWidth}, noop);
	def("lineCap", function() {return state.lineCap}, noop);
	def("lineJoin", function() {return state.lineJoin}, noop);
	def("lineDashOffset", function() {return state.lineDashOffset}, noop);
	def("miterLength", function() {return state.miterLength}, noop);

	def("font", function() {return state.font}, noop);
	def("textAlign", function() {return state.textAlign}, noop);
	def("textBaseline", function() {return state.textBaseline}, noop);

	def("shadowOffsetX", function() {return state.shadowOffsetX}, noop);
	def("shadowOffsetY", function() {return state.shadowOffsetY}, noop);
	def("shadowBlur", function() {return state.shadowBlur}, noop);
	def("shadowColor", function() {return state.shadowColor}, noop);


	/*------------------------------------------------------------------

		Public methods

	------------------------------------------------------------------*/

	this.save = function() {
		stack.push(state);
		state = new _8bit.State(palette, state);
		return me
	};

	this.restore = function() {
		var s = stack.splice(stack.length - 1)[0];
		if (s) {
			state = s;
			matrix = state.matrix;
		}
		return me
	};

	this.createPattern = function(img, repeat) {
		return new _8bit.Pattern(img, repeat, me)
	};

	this.createLinearGradient = function(x1, y1, x2, y2) {
		return new _8bit.Gradient("l", {x1:x1, y1:y1, x2:x2, y2:y2}, me)
	};

	this.createRadialGradient = function(x1, y1, r1, x2, y2, r2) {
		return new _8bit.Gradient("r", {x1:x1, y1:y1, r1:r1, x2:x2, y2:y2, r2:r2}, me)
	};


	/*------------------------------------------------------------------

		Path methods - shares _8bit.Path2D methods

	------------------------------------------------------------------*/

	this.beginPath = function() {
		iPath = new _8bit.Path2D(matrix);
		return this
	};

	this.closePath = function() {iPath.closePath(); return me};
	this.moveTo = function(x, y) {iPath.moveTo(x, y); return me};
	this.lineTo = function(x, y) {iPath.lineTo(x, y); return me};
	this.arc = function(x, y, r, sa, ea, ccw) {iPath.arc(x, y, r, sa, ea, !!ccw); return me};
	this.arcTo = function() {iPath.arcTo.apply(iPath, arguments); return me};
	this.rect = function(x, y, w, h) {iPath.rect(x, y, w, h); return me};
	this.ellipse = function() {iPath.ellipse.apply(iPath, arguments); return me};
	this.bezierCurveTo = function(cx1, cy1, cx2, cy2, x2, y2) {iPath.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2); return me};
	this.quadraticCurveTo = function(cx, cy, x, y) {iPath.quadraticCurveTo(cx, cy, x, y); return me};

	this.stroke = function(path) {
		tmpRender.stroke((path || iPath).paths, state, me);
		tmpRender.drawToRender(intRender);
		intRender.drawToCtx(_ctx, canvas.width, canvas.height);
		return me
	};

	this.fill = function(path, type) {
		// todo only evenodd is supported for now
		if (isStr(path)) {
			type = path;
			path = null;
		}
		tmpRender.fill((path || iPath).paths, state, me, type || "nonzero");
		tmpRender.drawToRender(intRender);
		intRender.drawToCtx(_ctx, canvas.width, canvas.height);
		return me
	};

	this.clip = function() {
		//todo clip()
	};

	/*------------------------------------------------------------------

		Non-Path methods - draws directly to canvas

	------------------------------------------------------------------*/

	this.drawImage = function(img, x, y, w, h, dx, dy, dw, dh) {

		x |= 0;
		y |= 0;

		if (isNum(w)) {
			w |= 0; h |= 0
		}

		if (isNum(dx)) {
			dx |= 0; dy |= 0;
			dw |= 0; dh |= 0
		}

		var idata;

		if (img instanceof HTMLImageElement) {
			if (arguments.length === 9) {
				var tmp = _8bit.utils.getContext(dw, dh, true);
				tmp.drawImage(img, x, y, w, h, 0, 0, dw, dh);
				x = dx;
				y = dy;
				w = dw;
				h = dh;
				idata = _8bit.Image.convert(tmp.canvas, w, h, me);

			}
			else {
				idata = img.__8bit || _8bit.Image.convert(img, w || img.naturalWidth || img.width, h || img.naturalHeight || img.height, me);
			}

			//todo auto GC cache after 10s or so using closure and timer
			img.__8bit = idata;
		}
		else if (img instanceof HTMLVideoElement) {
			idata = _8bit.Image.convert(img, w || img.videoWidth || img.width, h || img.videoHeight || img.height, me);
		}
		else if (img instanceof _8bit.Image) {
			idata = img.bitmap
		}

		tmpRender.drawImage(idata, state, x, y);
		tmpRender.drawToRender(intRender);
		intRender.drawToCtx(_ctx, canvas.width, canvas.height);
	};

	this.createImageData = function(w, h) {
		return intRender.ctx.createImageData(w, h)
	};

	this.getImageData = function(x, y, w, h) {
		return intRender.ctx.getImageData(x, y, w, h)
	};

	this.putImageData = function(idata, x, y) {
		intRender.ctx.putImageData(idata, x, y);
		return me
	};

	this.clearRect = function(x, y, w, h) {
		// We provide state to the clear method as we will clear the
		// intermediate renderer and not temp. This in order to correctly
		// apply current transformations..
		intRender.clearRect(x, y, w, h, state);
		intRender.drawToCtx(_ctx, canvas.width, canvas.height);
		return me
	};

	this.strokeRect = function(x, y, w, h) {
		var path = new _8bit.Path2D(matrix);
		path.rect(x, y, w, h);
		path.closePath();
		me.stroke(path);
		return me
	};

	this.fillRect = function(x, y, w, h) {
		var path = new _8bit.Path2D(matrix);
		path.rect(x, y, w, h);
		path.closePath();
		me.fill(path);
		return me
	};

	/*------------------------------------------------------------------

		Text methods - uses bitmap in our case

	------------------------------------------------------------------*/

	this.fillText = noop;
	this.strokeText = noop;
	this.measureText = noop;

	/*------------------------------------------------------------------

		Transformation Matrix

	------------------------------------------------------------------*/

	this.getTransform = function() {return matrix};
	this.setTransform = function(a,b,c,d,e,f) {matrix.setTransform(a,b,c,d,e,f); return me};
	this.transform = function(a,b,c,d,e,f) {matrix.transform(a,b,c,d,e,f); return me};
	this.rotate = function(a) {matrix.rotate(a); return me};
	this.translate = function(x, y) {matrix.translate(x, y); return me};
	this.scale = function(sx, sy) {matrix.scale(sx, sy); return me};
	this.resetTransform = function() {matrix.reset(); return me};

	/*------------------------------------------------------------------

		Convenience Methods (set strict = false):

	------------------------------------------------------------------*/

	this.resetClip = function() {
		if (!notStrict()) {
			// todo resetClip()
		}
	};

	this.createConicalGradient = function(cx, cy, rot) {
		if (!notStrict()) {
			// todo createConicalGradient()
		}
	};

	this.circle = function(cx, cy, r) {
		if (notStrict()) {
			me.moveTo(cx + r, cy);
			me.arc(cx, cy, r, 0, Math.PI*2);
			me.closePath()
		}
		return me
	};

	this.line = function(x1, y1, x2, y2) {
		if (notStrict()) {
			me.moveTo(x1, y1);
			me.lineTo(x2, y2)
		}
		return me
	};

	this.roundRect = function(x, y, w, h, r) {
		if (notStrict()) {
			if (w - r*2 < 0) r = w * 0.5;
			if (h - r*2 < 0) r = h * 0.5;

			if (r <= 0) return me.rect(x, y, w, h);
			else {
				me.moveTo(x + w, y + h - r);
				me.arc(x + w - r, y + h - r, r, 0, Math.PI*0.5);			// br
				me.arc(x + r, y + h - r, r, Math.PI*0.5, Math.PI);			// bl
				me.arc(x + r, y + r, r, Math.PI, -Math.PI*0.5);				// ul
				me.arc(x + w -r, y + r, r, -Math.PI * 0.5, 0);				// ur
				me.closePath()
			}
		}
		return me
	};

	this.clear = function() {
		if (notStrict()) me.clearRect(0, 0, w, h);
		return me
	};

	/*------------------------------------------------------------------

		PRIVATE METHODS

	------------------------------------------------------------------*/

	function setStyle(s, dst) {
		state.styles[dst] = new _8bit.Style(palette, s, me.strict)
	}

	function setPalette(p) {
		palette = new _8bit.Palette(p)
	}

	function setCompMode(m) {
		var modes = [
				"source-over", "source-in", "source-out", "source-atop",
				"destination-over", "destination-in", "destination-out", "destination-atop",
				"xor", "copy"],
			i = modes.indexOf(m);

		if (i > -1) {
			intRender.ctx.globalCompositeOperation = m
		}
	}

	/*------------------------------------------------------------------

		INIT

	------------------------------------------------------------------*/

	function init() {

		// display canvas
		disableSmoothing();

		if (!supportsAlpha)
			_ctx.globalCompositeOperation = "copy";  // only needed if context option alpha isn't supported

		// this context
		me.palette = options.palette || _8bit.Palettes.CBM64;

		stack = [];
		state = new _8bit.State(palette);
		matrix = state.matrix;

		me.aspect = {
			x: w / canvas.width,
			y: h / canvas.height
		};

		// init first path
		me.beginPath();
		me.clearRect(0, 0, w, h)
	}

	init();
	canvas.addEventListener("resize", init);

	/*------------------------------------------------------------------

		"ALL YOUR BASE ARE BELONG TO US!" (or system patches/"takeovers"

	------------------------------------------------------------------*/

	// cross-patch
	canvas.toDataURL = intRender.canvas.toDataURL.bind(intRender.canvas);
	canvas.toBlob = intRender.canvas.toBlob.bind(intRender.canvas);

	canvas.__8ael = canvas.addEventListener;
	canvas.__8rel = canvas.removeEventListener;

	canvas.addEventListener = function(name, func, f) {

		var cb = func.bind(canvas);

		function callback(e) {
			if (e instanceof MouseEvent) {
				cb(new _8bit.MouseEvent(canvas, me, e))
			}
			else
				cb(e)
		}

		canvas.__8ael(name, callback, f);

		// set internally as we need access to callback wrapper, and
		// there is no need for remEL before addEL.
		canvas.removeEventListener = function(name, func, f) {
			canvas.__8rel(name, callback, f)
		}
	};

	/*------------------------------------------------------------------

		HELPER METHODS

	------------------------------------------------------------------*/

	// turn off image smoothing for display canvas
	function disableSmoothing() {
		_8bit.utils.disableSmoothing(_ctx)
	}

	function notStrict() {
		if (me.strict)
			console.warn("context.strict must be set to false for this method to work.");

		return !me.strict
	}

	function isNum(o) {return typeof o === "number"}
	function isBool(o) {return typeof o === "boolean"}
	function isStr(o) {return typeof o === "string"}

	function def(name, getter, setter) {
		Object.defineProperty(me, name, setter ? {get: getter, set: setter} : {get: getter});
	}
}

_8bit.Shaders = {};


/**
 * Use this global constant or variable to disable patching of the
 * system's HTMLCanvasElement and CanvasRenderingContext2D if you so prefer.
 * Must be set to true **before** 8bit is loaded.
 *
 * The alternative way to create an 8-bit instance is:
 *
 *     var ctx = new _8Bit(canvas, options);
 *
 * The patch is provided for convenience and will not cause any problems
 * or interruptions.
 *
 * @const NO8BITPATCH
 * @type {boolean}
 */
if (typeof NO8BITPATCH === "undefined") {

	/**
	 *	This canvas extension allow this use:
	 *
	 *		var retro = canvas.getContext('8-bit');    // or "8bit"
	 *
	 * This allow developer to change minimal of existing code as the methods
	 * and properties are compatible. Only size and a palette needs to be
	 * changed.
	 *
	 *	@private
	 */
	window.HTMLCanvasElement.prototype.___8GC = window.HTMLCanvasElement.prototype.getContext;
	window.HTMLCanvasElement.prototype.getContext = function(type, options) {

		if (type.toLowerCase().replace("-", "") === '8bit') {
			var ctx = new _8bit(this, options || {});
			return this.__is8 ? ctx : null
		}
		else
			return this.___8GC(type, options);
	};

	HTMLCanvasElement.prototype.___8PSC = HTMLCanvasElement.prototype.probablySupportsContext || null;
	HTMLCanvasElement.prototype.probablySupportsContext = function(type) {
		if (type.toLowerCase().replace("-", "") === '8bit') return true;	// !note does not take into account low resources
		if (this.___8PSC)
			return this.__is8 ? false : this.___8PSC.apply(this, arguments);
		else
			return !this.__is8 && this.getContext.apply(this, arguments) !== null
	}
}

/*
	MouseEvent for addEventListener on main canvas
	(c) 2016 Epistemex
	www.epistemex.com
*/

_8bit.MouseEvent = function(canvas, ctx, e) {

	var rect = canvas.getBoundingClientRect(),
		x = e.clientX - rect.left,
		y = e.clientY - rect.top,
		aspect = ctx.aspect;

	this.x = (x * aspect.x)|0;
	this.y = (y * aspect.y)|0;
	this.clientX = rect.left + this.x;
	this.clientY = rect.top + this.y;
	this.altKey = e.altKey;
	this.button = e.button;
	this.buttons = e.buttons;
	this.ctrlKey = e.ctrlKey;
	this.metaKey = e.metaKey;
	this.shiftKey = e.shiftKey;
	this.relatedTarget = e.relatedTarget;

	this.target = e.target;
	this.currentTarget = e.currentTarget;
	this.eventPhase = e.eventPhase;
	this.timeStamp = e.timeStamp;
	this.type = e.type;
	this.isTrusted = true;
	this.bubbles = e.bubbles;
	this.cancelable = e.cancelable;

	this.preventDefault = e.preventDefault.bind(e);
	this.stopPropagation = e.stopPropagation.bind(e);
	this.stopImmediatePropagation = e.stopImmediatePropagation.bind(e);

	//this.defaultPrevented  todo this must be set from within the preventDefault() call

	this.originalEvent = e;

	this.region = null;			// todo hit-region support (iterate paths)

};/*
	8-bit utils
	� 2016 Epistemex
	www.epistemex.com
*/
_8bit.utils = {

	getContext: function(w, h, noAlpha) {
		var c = document.createElement("canvas");
		c.width = w;
		c.height = h;
		return c.getContext("2d", {alpha: !noAlpha})
	},

	contextSupportAlphaOption: function() {
		return document.createElement("canvas").getContext("2d", {alpha: false}).getImageData(0,0,1,1).data[3] === 255
	},

	disableSmoothing: function(ctx) {
		var px = ["i", "webkitI", "mozI", "msI", "oI", "khtmlI"], i = 0, p;
		while(p = px[i++]) {
			if (typeof ctx[p + "mageSmoothingEnabled"] !== "undefined") {
				ctx[p + "mageSmoothingEnabled"] = false;
				break
			}
		}
	}

};/*
	8-bit Style object
 */

_8bit.Style = function(palette, value, isStrict) {

	this.original = value;

	// Convert CSS name/definition to RGB values
	if (typeof value === "string") {
		this.color = palette.getNearestColor(_8bit.Color.fromCSS(value));
		this.style = this.color.toInt();
		this.type = _8bit.Style.type.solid;
	}

	else if (typeof value === "number" && isStrict) {
		throw "Using index requires strict to be set to false."
	}

	// Use an index (set strict = false)
	else if (typeof value === "number" && !isStrict) {
		value = Math.max(0, Math.min(palette.length - 1, value));
		this.color = palette.lut[value];
		this.style = palette._lutCache[value];
		this.type = _8bit.Style.type.solid;

	}

	// pattern
	else if (value instanceof _8bit.Pattern) {
		this.type = _8bit.Style.type.pattern;
	}

	// gradient
	else if (value instanceof _8bit.Gradient) {
		this.type = _8bit.Style.type.gradient;
	}

};

_8bit.Style.type = {
	solid: 0,
	pattern: 1,
	gradient: 2
};/*
	8-bit stack object
	� 2016 Epistemex
	www.epistemex.com
*/
_8bit.State = function(palette, src) {

	this.styles = [new _8bit.Style(palette, 1, false), new _8bit.Style(palette, 1, false), new _8bit.Style(palette, 0, false)];
	this.lineWidth = 1;
	this.lineJoin = "miter";
	this.lineCap = "butt";
	this.lineDashPattern = [];
	this.lineDashOffset = 0;
	this.miterLength = 10;
	this.matrix = new _8bit.Matrix();
	this.textBaseline = "baseline";
	this.textAlign = "start";
	this.direction = "LTR";
	this.font = "10px sans-serif";
	this.shadowOffsetX = 0;
	this.shadowOffsetY = 0;
	this.shadowBlur = 0;
	this.shadowColor = "#000";
	//this.globalAlpha = 1;
	this.globalCompositeOperation = "source-over";
	this.imageSmoothingEnabled = true;
	this.imageSmoothingQuality = "low";

	if (src) this.init(src)
};

_8bit.State.prototype = {

	init: function(src) {
		for(var k in src) {
			if (src.hasOwnProperty(k)) this[k] = src[k]
		}
	}

};/*
	8-bit Predefined Palette definitions to use with the Palette object.
	� 2016 Epistemex
	www.epistemex.com
*/

/**
 * Pre-defined palettes based on actual retro computers. Additional
 * palettes represents monochromatic screens, teletext and so on.
 *
 * These can be used with the Palette object:
 *
 *     var palette = new _8bit.Palette(_8bit.Palettes.CGA);
 *
 * or passed directly to the context's `palette` property:
 *
 *     ctx.palette =_8bit.Palettes.AMIGA;
 *
 * @type {*}
 */
_8bit.Palettes = {
	AMIGA: [0,0,0xffffff,0xaa7756,0xff0000,0xff00ff,0xffff00,0xffffff,8804,21740,1114006,48880,7895160,0xaaaaaa,7902890,9874156],
	BW: [0,0xffffff],
	GREEN: [0,65280],
	CBM64: [0,0xffffff,13306,0xffe01d,0xd249a9,5356136,0xd8444f,4517631,23551,16321,4092671,6316128,9211020,9961395,0xff97a3,0xe6b7c8],
	CBM64G: [0,0xffffff,2832232,0xb2a470,8797551,4427096,7940149,7325624,2445167,14659,5859226,4473924,7105644,8704666,0xb55e6c,9803157],
	VIC20: [0,0xffffff,2238840,0xddd687,0xb65faa,4825173,9253184,7524031,4813994,9024746,6449592,0xffffc7,0xf69fea,9035924,0xcc7180,0xb2ffff],
	AMSTRADCPC: [0,8388608,0xff0000,128,8388736,0xff0080,255,8388863,0xff00ff,32768,8421376,0xff8000,32896,8421504,0xff8080,33023,8421631,0xff80ff,65280,8453888,0xffff00,65408,8454016,0xffff80,65535,8454143,0xffffff],
	APPLEII: [0,4204908,7877952,0xf03cd9,4216595,8421504,0xf09726,0xf8b4bf,478016,0xf68d9,8421504,0xbfa8ec,0xfc326,8899263,0xbfd693,0xffffff],
	ZXSPECTRUM: [0,0xc00000,192,0xc000c0,49152,0xc0c000,49344,0xc0c0c0,0,0xff0000,255,0xff00ff,65280,0xffff00,65535,0xffffff],
	BBC: [0,255,65280,0xff0000,0xffff00,0xff00ff,65535,0xffffff],
	CGA: [0,0xaa0000,43520,0xaaaa00,170,0xaa00aa,21930,0xaaaaaa,5592405,0xff5555,5635925,0xffff55,5592575,0xff55ff,5636095,0xffffff],
	MSX: [0,0,4831294,8245364,0xe05559,0xf17680,5332665,0xefdb65,5858779,8227327,6210508,8900830,4301370,0xb566b7,0xcccccc,0xffffff],
	TELETEXT: [0,0xff0000,255,0xff00ff,65280,0xffff00,65535,0xffffff],
	THOMSONMO5: [0,255,65280,65535,0xff0000,0xff00ff,0xffff00,0xffffff,0xbbbbbb,7829469,7855479,7855581,0xdd7777,0xee77dd,0xffffbb,48110],
	NES: [8158332,0xfc0000,0xbc0000,0xbc2844,8650900,2097320,4264,5256,12368,30720,26624,22528,5783552,0,0,0,0xbcbcbc,0xf87800,0xf85800,0xfc4468,0xcc00d8,5767396,14584,1072356,31916,47104,43008,4499456,8947712,0,0,0,0xf8f8f8,0xfcbc3c,0xfc8868,0xf87898,0xf878f8,9984248,5798136,4497660,47352,1636536,5560408,0x98f858,0xd8e800,7895160,0,0,0xfcfcfc,0xfce4a4,0xf8b8b8,0xf8b8d8,0xf8b8f8,0xc0a4f8,0xb0d0f0,0xa8e0fc,7919864,7928024,0xb8f8b8,0xd8f8b8,0xfcfc00,0xf8d8f8,0,0],
	INTELLIVISION: [0,0xff96a5,1129983,5773749,28244,5744384,2143487,0xabcfc9,0xff2e00,0xffb824,5787391,0xc748bc,4221752,8440693,5237498,0xffffff],
	GAMEBOY: [1917696,4025600,2341738,2411641],
	EGA: [0,0xae0049,2407936,0xb0b300,192,0xad00ca,177820,0xaeaaa9,6160421,0xff006e,6470656,0xffa100,5898434,0xfe00d7,6206367,0xff96b9,1204736,0xaf452a,3538688,0xb2ff00,19384,0xad00c3,2883396,0xb1ff60,6249472,0xff005f,6815488,0xffff00,5981115,0xfe00d1,6618955,0xffff7d,98,0xae0076,2210816,0xb0b100,255,0xaa00ff,43007,0xac9aff,6094951,0xff008e,6404608,0xff9f53,5439743,0xfd00ff,5809407,0xfe84ff,24144,0xae3d69,3407616,0xb2ff00,255,0xab00ff,327660,0xaefff4,6182742,0xff0084,6749952,0xffff00,5505279,0xfd00ff,6225902,0xffffff],
	SEGA: [0,6160421,0xae0048,0xfe006d,97,6029414,0xae0077,0xfe008e,191,5898434,0xab00c9,0xfe00d7,255,5505279,0xaa00ff,0xfc00ff,1270272,6183936,0xae422b,0xfe005e,613456,6117206,0xaf3c68,0xfe0082,19640,5915067,0xad00c2,0xfe00d1,255,5505279,0xab00ff,0xfb00ff,2407936,6405376,0xb0b300,0xffa100,2145280,6339072,0xafb100,0xff9d53,374173,6205856,0xaea9a8,0xff96b9,43007,5744127,0xab98ff,0xfd83ff,3538688,6815488,0xb3ff00,0xffff00,3407616,6815488,0xb2ff00,0xffff00,2883395,6487879,0xb0ff60,0xffff7f,983020,6225902,0xaffff4,0xfffeff],
	AQUARIUS: [1906968,4077623,2162879,255,5627392,3866368,8323056,1441013,9306207,0xdf0064,0xcd00f1,0xfd00ff,0xb0b300,0xd0d700,0xcfcccb,0xffffff],
	ATARI2600NTSC: [0,4867139,7630188,9867407,0xb4b0af,0xcbc8c7,0xdedcdb,0xedecec,19521,1928541,3181947,4172436,4899755,5889218,6682329,7405548,6780,1523599,3037602,4421556,5475523,6463954,7256032,8573416,148,1380009,3424444,5069777,6387424,7638255,8692474,9943039,154,2162863,4194500,6110932,7625956,9140212,0xa392ff,0xb6a7ff,6488204,7930018,9175223,0xa028c7,0xb34ed7,0xc267e7,0xd185f1,0xe09cff,8323168,9764985,0xa80090,0xbb26a4,0xce4cb7,0xdd64cb,0xec82d9,0xfc99e8,9044031,0x9d0052,0xb00068,0xc32f80,0xd25391,0xe170a6,0xed8eb7,0xfca3ca,9306170,0xa10047,0xb40058,0xc33e68,0xd35e7a,0xe27a8a,0xed9799,0xfcacab,8585266,9836347,0xad414d,0xc0625d,0xcf7d6f,0xde9280,0xedad90,0xfdc2a2,6629142,8342047,9856564,0xb18247,0xc49b5c,0xd7b46c,0xeacd7d,0xfde191,3688960,5465344,7177728,8955392,0x9bbf20,0xb2dd33,0xc5f151,0xd8ff64,542720,3041280,5015552,6727936,8241723,9756500,0xaaf375,0xbeff86,410368,2778880,4491303,6005832,7520605,8772214,9958286,0xaaffa0,14635,2644039,4159582,5674105,7188878,8440485,9363134,0xa2f7d0,11339,2247785,3763079,5015713,6267065,7518416,8573416,9561852],
	ATARI2600PAL: [0,4867139,7630188,9867407,0xb4b0af,0xcbc8c7,0xdedcdb,0xedecec,23173,2651032,4491179,6266814,7778254,9028573,0xa0d3ee,0xb3e2ff,681776,3048260,4758620,6469745,7982213,9232787,0xa2f6a1,0xb5ffb6,12411,2575762,4416938,6259388,7771856,9022181,0xa0bef4,0xb3d3ff,2454016,4361984,6072064,7782144,9294592,0xa3e733,0xbaf663,0xcdff7b,1507455,3801241,5636275,7421639,8936156,0x9f6ef2,0xb688ff,0xc99eff,6644480,8157952,9671424,0xaaab1e,0xbdbf47,0xccce61,0xdfe27d,0xeef295,6488195,7995546,9240746,0xa02ebe,0xb352c9,0xc26ad9,0xd188e3,0xe19ef2,7878420,9393435,0xa5722e,0xb98b43,0xcca358,0xdfb76c,0xeecc7e,0xfde191,7798894,9240707,0xa40098,0xb726ac,0xca4dbb,0xdd64cb,0xec82d9,0xfc99e8,7798826,9316918,0xa54b47,0xb86b57,0xcb7e6e,0xde987e,0xedad90,0xfdc2a2,8781911,0x99006e,0xac0085,0xbf2998,0xce4faa,0xdd67be,0xed85cb,0xfc9bda,9306170,0xa10049,0xb4005c,0xc33471,0xd25684,0xe26d96,0xed8aab,0xfc9fbd],
	CBM16: [0,2827813,106,5258240,7536753,1202944,7667771,604438,105,8773,936192,2621548,2967808,7676959,7667797,1069568,0,4801346,1900684,7297792,9568407,1604352,9633879,743221,9353,16995,1272576,4653198,4942080,9717783,9633911,2716416,0,6840672,4012202,9337600,0xaf00b8,2727424,0xb03075,2259281,1067177,1794690,2460672,6625710,6916608,0xb06a1f,0xae0097,4625408,0,8814719,6118091,0xac9b00,0xcd00db,4439808,0xce5694,4168047,3631304,3965601,4369920,8668624,8890624,0xcf8a39,0xcc20b8,6599936,0,0xa39e9d,8157932,0xcbbb34,0xec00ff,6349056,0xed76b2,6076813,5736681,6005440,6278980,0xa166f4,0xa5ca00,0xecaa55,0xeb51da,8574720,0,0xc2bebd,0x9a9bff,0xe8dc55,0xfd50ff,8322816,0xfe9dcf,8051116,7776255,7848928,8122474,0xc087ff,0xc4ea35,0xffcc6d,0xfe7df9,0xa0f800,0,0xe0dede,0xbbc1ff,0xfffe77,0xfd8dff,0x9aff42,0xfec4eb,9960140,9752575,9822975,0x99ff8c,0xdfafff,0xe2ff63,0xfff480,0xfda9ff,0xbfff4f,0,0xfffeff,0xdbe6ff,0xffffa8,0xfed5ff,0xb7ff94,0xfeebff,0xb7ffc7,0xb6f4fc,0xb6fff5,0xb7ffc7,0xfed5ff,0xffffa8,0xffffa8,0xfed5ff,0xdbff9d],
	CBMP4: [0,2893349,4867139,6840929,8880511,0xa49f9e,0xc2bfbe,0xe1dfde,0xffffff,106,1900683,4143275,6183629,8223726,0x9c9bff,0xbbc1ff,0xdae7ff,5258240,7298048,9272320,0xac9c00,0xcabc31,0xe9dc57,0xfffe78,0xffffa7,7602290,9568406,0xaf00b8,0xcd00dc,0xeb00ff,0xfd51ff,0xfe90ff,0xfed5ff,940800,1670400,2727680,4505600,6414592,8322816,0x9bff3e,0xb8ff95,7602235,9633880,0xb03175,0xce5694,0xed77b3,0xff9cd0,0xffc4ea,0xffebff,145688,416053,2193745,4168048,6142349,8051372,0x98fbcc,0xb7ffc8,106,8842,411817,3631306,5736938,7776767,9883647,0xb5f5fd,9030,17251,1794945,3900320,5940159,7914463,9889023,0xb6fff5,674304,1207040,2460672,4304128,6278726,8188012,0x9aff8e,0xb7ffc8,2621547,4653198,6691503,8668625,0xa266f3,0xc088ff,0xdfafff,0xfed5ff,2968064,4942336,6982144,8956160,0xa6ca00,0xc4eb31,0xe2ff61,0xffffa7,7677215,9652501,0xb16a1e,0xcf8b38,0xeeaa56,0xffcd6d,0xfff481,0xffffa7,7602261,9568374,0xb00097,0xce24b9,0xec53da,0xfe7df9,0xfea9ff,0xfed7ff,807424,2716672,4691200,6665728,8640256,0xa1f800,0xbfff4f,0xdcff9d],
	MSX2: [0,6160421,0xae0048,0xfe006d,46,6094905,0xae0053,0xfd0074,86,6094939,0xae006c,0xfe0086,124,6029439,0xae008c,0xfe00a0,164,5898407,0xae00b0,0xfe00c0,205,5832911,0xac00d6,0xfd00e3,248,5701881,0xab00ff,0xfd00ff,255,5505279,0xaa00ff,0xfc00ff,601856,6167833,0xae0043,0xff006b,11558,6166835,0xae0050,0xfe0072,9808,6226008,0xae0069,0xfe0084,4729,6029438,0xad0089,0xfe009f,163,6029478,0xae00af,0xfe00be,205,5832910,0xad00d5,0xfd00e2,246,5701881,0xab00ff,0xfd00ff,255,5505279,0xaa00ff,0xfc00ff,1135872,6311424,0xae2b35,0xff0062,1070080,6245402,0xae2b44,0xff006b,610629,6179661,0xaf2261,0xfe007e,19315,6046582,0xae0684,0xfe0099,16799,5977761,0xaf00ab,0xfe00bb,11977,5906379,0xae00d3,0xfe00df,243,5767413,0xac00fb,0xfd00ff,255,5570815,0xaa00ff,0xfb00ff,1604352,6256384,0xae6600,0xfe3a51,1538816,6256128,0xae6526,0xff385c,1341734,6190133,0xaf6450,0xff3372,619878,6123881,0xaf5f79,0xfe2890,29077,6056600,0xad59a3,0xfe00b4,27072,5923269,0xad4ecc,0xfe00da,23791,5724144,0xac3cf6,0xfd00ff,19711,5457151,0xab0aff,0xfb00ff,2138880,6332928,0xb09600,0xff7f28,2073344,6332416,0xb09500,0xff803a,1876736,6266368,0xb09427,0xff7c5d,1548359,6265938,0xae9165,0xff7781,367750,6199690,0xae8d95,0xff72a7,38839,6001849,0xad88c0,0xfd6dcf,37093,5868777,0xad7fef,0xfd62f9,34559,5669887,0xab73ff,0xfd52ff,2607872,6605056,0xb0c100,0xffb100,2542336,6474240,0xb1c100,0xffb000,2411008,6473728,0xb0be00,0xffaf2d,2214144,6341888,0xb0be3f,0xffad67,1754480,6341490,0xafbb80,0xffaa96,508583,6209450,0xaeb7b3,0xffa5c2,48601,6076894,0xaeb1e4,0xfe9ff0,46847,5813503,0xadaaff,0xfd97ff,3077376,6681088,0xb2ed00,0xffe000,3011584,6615808,0xb2ec00,0xffdf00,2946048,6615552,0xb2eb00,0xffdf00,2748928,6615040,0xb2ea00,0xffde29,2486328,6483274,0xb1e85e,0xffda7b,1961359,6482836,0xafe49d,0xffd8b0,846282,6154188,0xaee0d3,0xffd4e0,58621,6087422,0xaedcff,0xfeceff,3538688,6815488,0xb3ff00,0xffff00,3538688,6749952,0xb3ff00,0xffff00,3407616,6749952,0xb2ff00,0xffff00,3276544,6749952,0xb1ff00,0xffff00,3079936,6553344,0xb1ff00,0xffff47,2752361,6487920,0xb0ff7d,0xffff94,2162612,6356917,0xb0ffbf,0xffffcc,983020,6225902,0xaffff4,0xfffeff],
	WIN16: [0,393342,1146896,1409152,8324353,8323199,8356113,0xc0c0c0,8421504,1507580,3014443,3473151,0xfb1404,0xfc00fc,0xfeff2c,0xffffff],
	WIN20: [0,393342,1146896,1409152,8324353,8323199,8356113,0xc0c0c0,0xc1dcc1,0xefcba7,0xf0fbff,0xa4a0a0,8421504,1507580,3014443,3473151,0xfb1404,0xfc00fc,0xfeff2c,0xffffff],
	MACII: [0xffffff,3473151,1926141,1245403,9961724,9897523,0xc90d02,0xfc9b18,1747481,747018,471653,3630488,0xbbbbbb,8947848,4473924,0],
	ACORN: [0xffffff,0xdddddd,0xbbbbbb,0x999999,7829367,5592405,3355443,0,9913606,3206638,2280480,1245402,0xbdeeee,1345623,2734845,0xfdbc1e],
	G_PACMAN: [0,0xffffff,5908000,555724,564172,6121694,1150836,281054,0xc8bdb5,0xa24368,3834954],
	G_DONKEY: [0,0xffffff,5617919,26879,184],
	G_SPACEINV: [0,0xffffff,64256,2171135,0xe5f5d0,4831206,621864,0xab0f9e,6687287],
	G_MONKEY: [0,0xffffff,0x9fffff,3842047,4143674,4654336,0xc0502f],
	G_MARIO: [0,0xffffff,609228,0xaabaff,0xfb945d,2259986,0xfffcdb,3442411,6247936,9804096,45128,0xec381f,0xf08a5f,0xba48f7,0xf1edf9,0xbdbdbd],
	G_ZELDA: [0,0xffffff,7895160,0xb6cffc,3375702,1654625,4759244,2385716,0xc8fbfe,8202557,1782422,0xa17206,0xd9b257,3849550,2639104,9550410]
};/*
	8-bit Palette object
	� 2016 Epistemex
	www.epistemex.com
*/

/**
 * Creates a Palette object and initializes it with the LUT array
 * which contains sub-array or [_8bit.Color]{@link _8bit.Color}
 * objects for each RGB color spot in the palette:
 *
 * <code>[ [r0, g0, b0], [r1, g1, b1], ..., [rn, gn, bn]]</code>
 * <code>[ new _8bit.Color(r0, g0, b0), ..., new _8bit.Color(rn, gn, bn)]</code>
 *
 * When using name it will set a pre-defined (built-in) palette
 * based on retro computers. These are the available built-in palettes:
 *
 * <pre>
 * ACORN         - 16 colors palette
 * AMIGA         - 16 colors palette (Amiga default for 16 colors mode)
 * AMSTRADCPC    - 27 colors palette
 * APPLEII       - 16 colors palette
 * AQUARIUS      - 16 colors palette
 * ATARI2600NTSC - 128 colors palette
 * ATARI2600PAL  - 104 colors palette
 * BBC           - 8 colors palette
 * BW            - 2 colors palette (mono b&w monitors)
 * C16           - 128 colors palette
 * CBM64         - 16 colors palette
 * CBM64G        - 16 colors palette (gamma corrected)
 * CBMP4         - 121 colors palette
 * CGA           - 16 colors palette
 * EGA           - 64 colors palette
 * GAMEBOY       - 4 colors palette
 * G_DONKEY      - 6 color palette (Donkey Kong)
 * G_MARIO       - 16 color palette (Super Mario Bros.)
 * G_MONKEY      - 7 color palette (Monkey Island)
 * G_PACMAN      - 11 color palette (PacMan)
 * G_SPACEINV    - 9 color palette (Space Invaders)
 * G_ZELDA       - 16 color palette (The Legend of Zelda)
 * GREEN         - 2 colors palette (mono green colored monitors)
 * INTELLIVISION - 16 colors palette
 * MACII         - 16 colors palette
 * MSX           - 15 colors palette
 * MSX2          - 256 colors palette
 * NES           - 64 colors palette
 * SEGA          - 64 colors palette
 * TELETEXT      - 8 colors palette (for TV tele-text)
 * THOMSONMO5    - 16 colors palette
 * VIC20         - 16 colors palette
 * WIN16         - 16 colors palette
 * WIN20         - 20 colors palette
 * ZXSPECTRUM    - 16 colors palette
 * </pre>
 *
 * @example
 * var palette = new _8bit.Palette(array);
 * var palette = new _8bit.Palette('name');
 *
 * @class _8bit.Palette
 * @param {String|Array} palette - Name of a pre-defined palette or a Look-up-table (Array) consiting of integer values or sub-array with r, g and b values
 * @param {String} [name] - optional parameter for custom palette array
 * @returns {_8bit.Palette}
 * @constructor
 * @prop {Array} lut - Look-up-table for palette colors
 * @prop {String} name - name of palette given as optional name argument.
 * For internal palette its name in upper-case, or defaults to '<code>custom</code>'
 * @prop {Number} length - number of indexes in this palette
 */
_8bit.Palette = function(palette, name) {

	var i = 0, e;

	/**
	 * Contains _8bit.Color objects for each palette entry.
	 * @type {Array}
	 */
	this.lut = [];

	// predefined palette?
	if (typeof palette === "string") {

		palette = palette.toUpperCase();

		if (_8bit.Palettes[palette]) {
			name = palette;
			palette = _8bit.Palettes[palette];
		}
		else
			throw 'Unknown palette name ' + palette;
	}

	// parse and convert entries
	this.name = name || 'custom';

	// convert palette definitions into entries (array/Color)
	while(i < palette.length) {

		e = palette[i++];

		if (e instanceof _8bit.Color) {
			this.lut.push(e);
		}
		else if (typeof e === "number") {
			this.lut.push(new _8bit.Color(0xff000000 | e));
		}
		else {
			if (!Array.isArray(e)) throw 'Invalid palette array at index ' + --i;
			this.lut.push(new _8bit.Color(e[0], e[1], e[2]));
		}
	}

	this.length = this.lut.length;

	// Cache integer values of this palette
	this._lutCache = new Uint32Array(this.length);
	for(i = 0; e = this.lut[i];) this._lutCache[i++] = e.toInt();

};

_8bit.Palette.prototype = {

	/**
	 * Returns a _8bit.Color object from the color at index in the LUT.
	 *
	 * @param {Number} index - Color index of the current palette array
	 * @returns {_8bit.Color}
	 */
	getColor: function(index) {

		if (index < 0) index = 0;
		if (index >= this.length) index = this.length - 1;

		return this.lut[index]
	},

	/**
	 * Get index of color spot in the LUT Palettes if the RGB values
	 * matches 100% or by tolerance. Returns -1 if no index matched.
	 *
	 * Tolerance is given as percentage [0, 100], default is 0%
	 * or no tolerance.
	 *
	 * @param {Number} r - red
	 * @param {Number} g - green
	 * @param {Number} b - blue
	 * @param {Number} [tolerance] Tolerance in percentage
	 * @returns {number}
	 */
	getIndex: function(r, g, b, tolerance) {

		tolerance = ((tolerance || 0) * 2.55 + 0.5)|0;

		var	lut = this.lut,
			c,
			i = 0,
			rmin, rmax, gmin, gmax, bmin, bmax;

		if (tolerance === 0) {
			for(; c = lut[i]; i++)
				if (r === c.r && g === c.g && b === c.b) return i;

		}
		else {
			rmin = r - tolerance;	rmax = r + tolerance;
			gmin = g - tolerance;	gmax = g + tolerance;
			bmin = b - tolerance;	bmax = b + tolerance;

			rmin = Math.max(0, Math.min(255, rmin));
			rmax = Math.max(0, Math.min(255, rmax));
			gmin = Math.max(0, Math.min(255, gmin));
			gmax = Math.max(0, Math.min(255, gmax));
			bmin = Math.max(0, Math.min(255, bmin));
			bmax = Math.max(0, Math.min(255, bmax));

			for(; c = lut[i]; i++) {
				r = c.r;
				g = c.g;
				b = c.b;
				if (r >= rmin && r <= rmax &&
					g >= gmin && g <= gmax &&
					b >= bmin && b <= bmax)	return i;
			}
		}

		return -1;
	},

	/**
	 *	Get the index of the nearest color in the LUT based on RGB.
	 *	The function will always return a valid index.
	 *
	 * @param {_8bit.Color} color - color object
	 * @returns {number} The index of the closest color
	 */
	getNearestColor: function(color) {

		var i = 0, c, d,
			min = Number.MAX_VALUE,
			col,
			lut = this.lut;

		while(c = lut[i++]) {
			d = color.diff(c);
			if (d < min) {
				min = d;
				col = c
			}
		}

		return col
	},

	/**
	 *	Get the index of the nearest color in the LUT based on RGB.
	 *	The function will always return a valid index.
	 *
	 * @param {number} r - color object
	 * @param {number} g - color object
	 * @param {number} b - color object
	 * @returns {Array} The index of the closest color
	 */
	getNearestColorRGB: function(r, g, b) {

		var i = 0, c, d,
			min = Number.MAX_VALUE,
			col= 0,
			lut = this.lut;

		while(c = lut[i++]) {
			d = color.diffRGB(r, g, b);
			if (d < min) {
				min = d;
				col = c;
			}
		}

		return col;
	}

	/**
	 * Get a color object of the nearest color in the LUT based on RGB.
	 * The function will always return a valid color object.
	 *
	 * @param {_8bit.Color} color - color object
	 * @returns {_8bit.Color}
	 */
	/*getNearestColor: function(color) {
		return this.lut[this.getNearestIndex(color)]
	}*/

};

/*
	8-bit Color object
	� 2016 Epistemex
	www.epistemex.com
*/
/**
 * Canvas8BitContext.COLOR object
 * @class _8bit.Color
 * @param {Number} [r] - red or Uint32
 * @param {Number} [g] - green
 * @param {Number} [b] - blue
 * @constructor
 */
_8bit.Color = function(r, g, b) {

	if (arguments.length === 1) {
		g = this.int2rgb(r);
		this.r = g[0];
		this.g = g[1];
		this.b = g[2];
		this.int32 = r;
	}
	else if (arguments.length === 3) {
		this.r = Math.min(Math.max(0, (r + 0.5)|0), 255);
		this.g = Math.min(Math.max(0, (g + 0.5)|0), 255);
		this.b = Math.min(Math.max(0, (b + 0.5)|0), 255);
		this.int32 = this.rgb2int(this.r, this.g, this.b);
	}
	else {
		this.r = 0;
		this.g = 0;
		this.b = 0;
		this.int32 = 0;
	}
};

_8bit.Color.fromCSS = function(css) {

	var div = document.createElement("div"),
		cs, rgb, a;

	// create a temp element
	div.style.cssText = "width:1px;height:1px;position:fixed;left:-10px;top:-10px;background-color:" + css;
	document.body.appendChild(div);
	cs = getComputedStyle(div).getPropertyValue("background-color");
	document.body.removeChild(div);

	rgb = cs === "transparent" ? "(0,0,0,0)" : (cs.substr(0, 3) === "rgb" ? cs : "(0,0,0)");
	rgb = rgb.substring(rgb.indexOf("(") + 1, rgb.length - 1);
	a = rgb.split(",");

	return new _8bit.Color(+a[0], +a[1], +a[2])
};

_8bit.Color.prototype = {

	/**
	 * Adds given _8bit.Color to current color of the instance and returns
	 * the result as a new _8bit.Color instance.
	 *
	 * @param {_8bit.Color} c Color object
	 * @returns {_8bit.Color}
	 */
	add: function(c) {
		return new _8bit.Color(this.r + c.r, this.g + c.g, this.b + c.b)
	},

	/**
	 * Subtracts given _8bit.Color to current color of the instance and
	 * returns the result as a new _8bit.Color instance.
	 *
	 * @param {_8bit.Color} c Color object
	 * @returns {_8bit.Color}
	 */
	sub: function(c) {
		return new _8bit.Color(this.r - c.r, this.g - c.g, this.b - c.b)
	},

	/**
	 * Returns a new _8bit.Color object holding the mixed
	 * values from this instance (full when t=0) and the given (full
	 * when t=1).
	 *
	 * @param {_8bit.Color} c - color to mix with
	 * @param {number} t - mix factor in the range [0.0, 1.0] where 0 = this instance, 1 = given color
	 * @returns {_8bit.Color}
	 */
	mix: function(c, t) {
		var r = this * t + c.r * (1 - t),
			g = this * t + c.r * (1 - t),
			b = this * t + c.r * (1 - t);

		return new _8bit.Color(r, g, b)
	},

	/**
	 * Multiplies given _8bit.Color to current color of the instance and
	 * returns the result as a new _8bit.Color instance.
	 *
	 * @param {Number} f - Multiplication factor
	 * @returns {_8bit.Color}
	 */
	mul: function(f) {
		return new _8bit.Color(this.r * f, this.g * f, this.b * f)
	},

	/**
	 * Bit-shifts current component values number of bit places given
	 * by bits to the right and returns the result as a new _8bit.Color
	 * instance.
	 *
	 * @param {Number} bits - Number of bits to shift
	 * @returns {_8bit.Color}
	 */
	rshift: function(bits) {
		return new _8bit.Color(this.r >> bits, this.g >> bits, this.b >> bits)
	},

	/**
	 * Bit-shifts current component values number of bit places given
	 * by bits to the left and returns the result as a new _8bit.Color
	 * instance.
	 *
	 * @param bits - Number of bits to shift
	 * @returns {_8bit.Color}
	 */
	lshift: function(bits) {
		return new _8bit.Color(this.r << bits, this.g << bits, this.b << bits)
	},

	/**
	 * Calculates a difference vector (non-squared) between the values
	 * of instance and the given color object.
	 *
	 * @param {_8bit.Color} c - Color object
	 * @returns {number} a number representing distance (non-squared)
	 */
	diff: function(c) {
		var dr = c.r - this.r,
			dg = c.g - this.g,
			db = c.b - this.b;
		return dr*dr + dg*dg + db*db
	},

	/**
	 * Calculates a difference vector (non-squared) between the values
	 * of instance and the given color object.
	 *
	 * @param {number} r - Color object
	 * @param {number} g - Color object
	 * @param {number} b - Color object
	 * @returns {number} a number representing distance (non-squared)
	 */
	diffRGB: function(r, g, b) {
		var dr = r - this.r,
			dg = g - this.g,
			db = b - this.b;
		return dr*dr + dg*dg + db*db
	},

	/**
	 * Calculates a difference vector (squared) between the values
	 * of instance and the given color object.
	 *
	 * @param {_8bit.Color} c - Color object
	 * @returns {number} a number representing distance (squared)
	 */
	diffSqrt: function(c) {
		return Math.sqrt(this.diff(c))
	},

	/**
	 * Returns a black or white color object depending on current color
	 * and threshold value. The current color is converted to a luma
	 * value and if below threshold a black color is returned, above a
	 * white color is returned
	 *
	 * @param {Number} t - Threshold value [0, 255] inclusive
	 * @returns {_8bit.Color}
	 */
	threshold: function(t) {
		var luma = this.r * 0.299 + this.g * 0.587 + this.b * 0.114;
		return luma >= t ? new _8bit.Color(255, 255, 255) : new _8bit.Color(0, 0, 0)
	},

	/**
	 * Inverts the current RGB and returns the result as a new
	 * _8bit.Color instance.
	 *
	 * @returns {_8bit.Color}
	 */
	invert: function() {
		return new _8bit.Color(255 - this.r, 255 - this.g, 255 - this.b)
	},

	/**
	 * Set new color values for this instance. Use this method instead of
	 * setting the RGB properties directly if you need the integer
	 * representation.
	 *
	 * @param {Number} r - red
	 * @param {Number} g - green
	 * @param {Number} b - blue
	 * @returns {_8bit.Color}
	 */
	setRGB: function(r, g, b) {

		this.r = r;
		this.g = g;
		this.b = b;
		this.int32 = this.rgb2int(r, g, b);

		return this
	},

	/**
	 *	Updates the current instance with new color value based on
	 *	the 32-bits integer value. The provided value must reflect the byte-
	 *	order of the system. Updates the RGB properties.
	 *
	 * @param {Number} i - Integer representation of a color.
	 * @returns {_8bit.Color}
	 */
	setInteger: function(i) {

		//i = i|0;

		var c = this.int2rgb(i);

		this.int32 = i;
		this.r = c[0];
		this.g = c[1];
		this.b = c[2];

		return this
	},

	/**
	 * Convert RGB values into an unsigned integer based on byte-order.
	 * On a MSB system (big endian) the order will be RRGGBBAA and for
	 * LSB (little endian) AABBGGRR (each char representing an octet).
	 * The alpha channel is ignored in 8-bit and is always treated
	 * as 0xff (opaque).
	 *
	 * @type {Function}
	 * @private
	 */
	rgb2int: function(r, g, b) {
		return 0xff000000 + (b << 16) + (g << 8) + r
	},

	/**
	 * Convert RGB values into an unsigned integer based on byte-order.
	 * The byte-order (little endian) must be given as 0xAABBGGRR.
	 * (each char representing an octet and the color component). Alpha
	 * channel is ignored in 8-bit
	 *
	 * @param {Number} i - (unsigned) integer value to convert
	 * @returns {Array} Holding components for R (0), G (1) and B (2)
	 * @private
	 */
	int2rgb: function(i) {
		return [
			(i & 0xff),
			(i & 0xff00) >>> 8,
			(i & 0xff0000) >>> 16
			]
	},

	/**
	 * Returns the current RGB values as an Array.
	 *
	 * @returns {Array} Array with index 0 = red, 1 = green, 2 = blue
	 */
	toArray: function() {
		return [this.r, this.g, this.b]
	},

	/**
	 * Returns the current RGB values as an integer value.
	 *
	 * @returns {Number} 32-bits integer representing current color
	 */
	toInt: function() {
		return this.int32
	},

	/**
	 * Formats the current RGB values as a simple object with properties
	 * r, g, b holding the value for each component.
	 *
	 * @returns {{r: Number, g: Number, b: Number}}
	 */
	toObject: function() {
		return {
			r: this.r,
			g: this.g,
			b: this.b
		}
	},

	/**
	 * Formats the current RGB values as a comma-separated string.
	 *
	 * @returns {string} Simple comma-separated string
	 */
	toString: function() {
		return this.r + ',' + this.g + ',' + this.b
	},

	/**
	 * Formats the current RGB values as a string suitable for use
	 * with CSS and 2D context.
	 *
	 * @returns {string} CSS style compatible string
	 */
	toStyle: function() {
		return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')'
	},

	/**
	 * Returns an object with min and max properties containing new
	 * _8bit.Color objects adjusted for tolerance. Tolerance is a
	 * fraction of 255 which is subtracted and added to the new
	 * objects respectively. The values will in any case be maxed at 255
	 * and never be less than 0.
	 *
	 * @param {Number} tolerance - Tolerance in the range [0.0, 1.0]
	 * @returns {{min: _8bit.Color, max: _8bit.Color}}
	 */
	getToleranceRange: function(tolerance) {

		var c1, c2, i = 0;

		c1 = [this.r, this.g, this.b];
		c2 = [this.r, this.g, this.b];

		for(; i < 3; i++) {
			c1[i] -= (255 * tolerance + 0.5)|0;
			c2[i] += (255 * tolerance + 0.5)|0;

			if (c1[i] < 0) c1[i] = 0;
			if (c2[i] > 255) c2[i] = 255;
		}

		return {
			min: new _8bit.Color(c1[0], c1[2], c1[3]),
			max: new _8bit.Color(c2[0], c2[2], c2[3])
		}
	},

	clone: function() {
		return new _8bit.Color(this.r, this.g, this.b)
	}
};
/*
	8-bit Gradient style object
	� 2016 Epistemex
	www.epistemex.com
*/
_8bit.Gradient = function(type, options, ctx8) {

	var w = ctx8.width,
		h = ctx8.height,
		c = _8bit.utils.getContext(1, 1),
		gradient, m, idata, buffer, isFirst = true;

	gradient = type === "l" ?
			  c.createLinearGradient(options.x1, options.y1, options.x2, options.y2) :
			  c.createRadialGradient(options.x1, options.y1, options.r1, options.x2, options.x2, options.r2);

	this._sm = function() {
		this._getPixel = m.isIdentity() ? setPixel : setPixelM
	};

	this._getPixel = null;

	function setPixelM(x, y) {
		var p = m.applyToPoint(x, y);
		x = p.x;
		y = p.y;
		return (x >= 0 && x < w && y >= 0 && y < h) ? buffer[y * w + x] : 0
	}

	function setPixel(x, y) {
		return (x >= 0 && x < w && y >= 0 && y < h) ? buffer[y * w + x] : 0
	}

	this._generate = function(ctx8) {

		var tm = ctx8.getTransform().inverse();

		if (!isFirst && tm.isEqual(m)) return;

		m = tm;
		isFirst = false;

		// create a normal gradient
		var	ctx = _8bit.utils.getContext(w, h);
		ctx.fillStyle = gradient;
		ctx.fillRect(0, 0, w, h);

		// convert to dithered bitmap
		idata = _8bit.Image.convert(ctx.canvas, w, h, ctx8);
		buffer = new Uint32Array(idata.data.buffer);

		//todo force opaque pixels

		this._sm()
	};

	this.addColorStop = function(t, color) {
		gradient.addColorStop(t, color);
		return this
	};
};
/*
	8-bit Pattern style object
	� 2016 Epistemex
	www.epistemex.com
*/

_8bit.Pattern = function(img, repeat, ctx) {

	if (typeof "repeat" === "undefined")
		throw "Type Mismatch: repeat cannot be undefined";

	var	funcs = [getPixelRepeat, getPixelRepeatX, getPixelRepeatY, getPixelNoRepeat],
		funcsM = [getPixelRepeatM, getPixelRepeatXM, getPixelRepeatYM, getPixelNoRepeatM],
		funcsTbl,
		index = ["repeat", "repeat-x", "repeat-y", "no-repeat"].indexOf(repeat),
		palette = ctx.palette,
		lm = ctx.getTransform().inverse(),
		w, h,
		idata, buffer;

	//todo handle Blob, ImageData, ImageBitmap types

	if (img instanceof HTMLImageElement) {
		w = img.naturalWidth || img.width;
		h = img.naturalHeight || img.height;
		idata = img.__8bit || _8bit.Image.convert(img, w, h, ctx);
		//todo auto GC cache after 10s or so using closure and timer
		img.__8bit = idata;
	}
	else if (img instanceof HTMLVideoElement) {
		w = img.naturalWidth || img.width;
		h = img.naturalHeight || img.height;
		idata = _8bit.Image.convert(img, w, h, palette, ctx);
	}
	else if (img instanceof _8bit.Image) {
		w = img.width;
		h = img.height;
		idata = img.bitmap
	}

	buffer = new Uint32Array(idata.data.buffer);

	this.setTransform = function(m) {
		lm.reset();
		lm.multiply(m.inverse());
		lm.multiply(ctx.getTransform().inverse());

		funcsTbl = lm.isIdentity() ? funcs : funcsM;
		this._getPixel = funcsTbl[index < 0 ? 0 : index];

		return this
	};

	funcsTbl = lm.isIdentity() ? funcs : funcsM;
	this._getPixel = funcsTbl[index < 0 ? 0 : index];

	function getPixelRepeat(x, y) {
		x = x % w;
		y = y % h;
		return buffer[y * w + x]
	}

	function getPixelRepeatX(x, y) {
		x = x % w;
		return (y >= 0 && y < h) ? buffer[y * w + x] : 0
	}

	function getPixelRepeatY(x, y) {
		y = y % h;
		return (x >= 0 && x < w) ? buffer[y * w + x] : 0
	}

	function getPixelNoRepeat(x, y) {
		return (x >= 0 && x < w && y >= 0 && y < h) ? buffer[y * w + x] : 0
	}

	function getPixelRepeatM(x, y) {
		var p = lm.applyToPoint(x, y);
		x = p.x % w;
		y = p.y % h;
		if (x < 0) x += w;
		if (y < 0) y += h;
		return buffer[y * w + x]
	}

	function getPixelRepeatXM(x, y) {
		var p = lm.applyToPoint(x, y);
		x = p.x % w;
		y = p.y;
		if (x < 0) x += w;
		return (y >= 0 && y < h) ? buffer[y * w + x] : 0
	}

	function getPixelRepeatYM(x, y) {
		var p = lm.applyToPoint(x, y);
		x = p.x;
		y = p.y % h;
		if (y < 0) y += h;
		return (x >= 0 && x < w) ? buffer[y * w + x] : 0
	}

	function getPixelNoRepeatM(x, y) {
		var p = lm.applyToPoint(x, y);
		x = p.x;
		y = p.y;
		return (x >= 0 && x < w && y >= 0 && y < h) ? buffer[y * w + x] : 0
	}

};/*
	8-bit Path2D object
 */

/**
 * Path2D equivalent for 8-bit context (private)
 * @constructor
 */
_8bit.Path2D = function(m) {
	this.paths = [new _8bit.Path2D.Path()];
	this.cp = 0;
	this.step = 0.025;
	this.matrix = m || new _8bit.Matrix();
	this.cx = 0;
	this.cy = 0;
};

_8bit.Path2D.prototype = {

	_new: function() {
		this.paths.push(new _8bit.Path2D.Path());
		this.cp = this.paths.length -1;
	},

	addPath: function(path2d, m) {
		var p, paths = this.paths;

		if (m) {
			path2d.paths.forEach(function(p) {
				paths.push(new _8bit.Path2D.Path(m.applyToArray(p.points)))
			});

			p = m.applyToPoint(path2d.cx, path2d.cy);
			this.cx = p.x;
			this.cy = p.y;
		}
		else {
			this.paths = paths.concat(path2d.paths);
			this.cx = path2d.cx;
			this.cy = path2d.cy;
		}

		this._new()
	},

	moveTo: function(x, y, noMatrix) {

		if (this.paths[this.cp].points.length) {
			this._new()
		}

		var p = noMatrix ? {x:x, y:y} : this.matrix.applyToPoint(x, y);
		this.paths[this.cp].add(p.x, p.y);

		this.cx = x;
		this.cy = y
	},

	closePath: function(){
		var path = this.paths[this.cp];
		if (path.points.length) {
			path.isClosed = true;
			this.moveTo(path.points[0], path.points[1], true);			// note: already transformed (would need inverse matrix)
		}
	},

	lineTo: function(x, y) {
		var p = this.matrix.applyToPoint(x, y);
		this.paths[this.cp].add(p.x, p.y);

		this.cx = x;
		this.cy = y
	},

	arc: function(x, y, r, sa, ea, ccw) {

		var path = this.paths[this.cp],
			step = 4 / (Math.PI * r),
			l = path.points.length,
			m = this.matrix, p;

		sa = sa % (Math.PI*2);
		ea = ea % (Math.PI*2);
		if (r < 0) throw new RangeError("IndexSizeError.");

		if (ccw) {
			if (sa < ea) ea -= Math.PI*2;
			if (sa === ea) ea -= Math.PI*2;
			for(; sa >= ea; sa -= step) {
				p = m.applyToPoint(x + r * Math.cos(sa), y + r * Math.sin(sa));
				path.add(p.x, p.y)
			}
		}
		else {
			if (sa > ea) ea += Math.PI*2;
			if (sa === ea) ea += Math.PI*2;
			for(; sa <= ea; sa += step) {
				p = m.applyToPoint(x + r * Math.cos(sa), y + r * Math.sin(sa));
				path.add(p.x, p.y)
			}
		}

		this.cx = path.points[l-2];
		this.cy = path.points[l-1]
	},

	arcTo: function(x1, y1, x2, y2, rx, ry, rot) {

		if (rx < 0) throw new RangeError("IndexSizeError.");

		if (typeof ry === "number") {
			if (ry < 0) throw new RangeError("IndexSizeError.")
		}
		else ry = rx;

		if (typeof rot !== "number") rot = 0;

		var path = this.paths[this.cp],
			l = path.points.length,
			x0 = l > 1 ? path.points[l-2] : x1-1,			//fixme arcTo def. start not correct in this case
			y0 = l > 1 ? path.points[l-1] : y1-1,
			t1 = (y1 - y0) / (x1 - x0),
			t2 = (y2 - y1) / (x2 - x1),
			t = Math.atan((t1 - t2) / (1 + t1 * t2)),
			th = rx / Math.tan(t * 0.5),
			xi =  Math.abs(Math.sqrt(th * th / (1 + t1 * t1))),
			yi = Math.abs(xi * t1),
			xi1 =  x1 > x0 ? x1 - xi : x1 + xi,
			yi1 = y1 > y0 ? y1 - yi : y1 + yi,
			t1i = -1 / t1,
			xi2, yi2, cx, cy;

		xi = Math.abs(Math.sqrt(th * th / (1 + t2 * t2)));
		yi = Math.abs(xi * t2);
		xi2 = x2 > x1 ? x1 + xi : x1 - xi;
		yi2 = y2 > y1 ? y1 + yi : y1 - yi;

		xi = Math.abs(Math.sqrt(rx * rx / (1 + t1i * t1i)));
		yi = Math.abs(xi * t1i);
		cx = xi1 + xi;
		cy = yi1 + yi;

		if (rx === 0)
			this.lineTo(x1, y1);

		if (rx === ry)
			this.arc(cx, cy, rx, Math.atan2(yi1 - cy, xi1 - cx), Math.atan2(yi2 - cy, xi2 - cx));
		else
			this.ellipse(cx, cy, rx, ry, rot, Math.atan2(yi1 - cy, xi1 - cx), Math.atan2(yi2 - cy, xi2 - cx));

	},

	ellipse: function(x, y, rx, ry, rot, sa, ea, ccw) {

		sa = sa % (Math.PI*2);
		ea = ea % (Math.PI*2);
		if (rx < 0 || ry < 0) throw new RangeError("IndexSizeError.");

		var path = this.paths[this.cp],
			l = path.points.length,
			step = 2 / (Math.PI * Math.min(rx, ry)),
			cos = Math.cos(rot),
			sin = Math.sin(rot),
			m = this.matrix,
			p, ex, ey;

		if (ccw) {
			if (sa < ea) ea -= Math.PI*2;
			for(; sa >= ea; sa -= step) {
				ex = rx * Math.cos(sa);
				ey = ry * Math.sin(sa);
				p = m.applyToPoint(
					x + cos * ex - sin * ey,
					y + sin * ex + cos * ey
				);
				path.add(p.x, p.y)
			}
		}
		else {
			if (sa > ea) ea += Math.PI*2;
			for(; sa <= ea; sa += step) {
				ex = rx * Math.cos(sa);
				ey = ry * Math.sin(sa);
				p = m.applyToPoint(
					x + cos * ex - sin * ey,
					y + sin * ex + cos * ey
				);
				path.add(p.x, p.y)
			}
		}

		this.cx = path.points[l-2];
		this.cy = path.points[l-1]
	},

	rect: function(x, y, w, h) {

		var path, p;

		this.moveTo(x, y);			// ul
		path = this.paths[this.cp];

		p = this.matrix.applyToArray([x + w, y, x + w, y + h, x, y + h]);
		path.add(p[0], p[1]);		// ur
		path.add(p[2], p[3]);		// br
		path.add(p[4], p[5]);		// bl
		this.closePath();

		this.cx = p[0];
		this.cy = p[1]
	},

	/**
	 * Renders a 2. order Bezier curve (quadratic).
	 * Each point is given as an integer value.
	 *
	 * @param {Number} cx - control point x
	 * @param {Number} cy - control point y
	 * @param {Number} x - end point x
	 * @param {Number} y - end point y
	 */
	quadraticCurveTo: function(cx, cy, x, y) {

		var path = this.paths[this.cp],
			l = path.points.length,
			sx = l > 1 ? this.cx : cx,
			sy = l > 1 ? this.cy : cy,
			step = this.step,
			m = this.matrix, p,
			t = step;

		// B(t) = (1-t)^2 * Z0 + 2(1-t)t * C + t^2 * Z1   for 0 <= t <= 1
		for(; t < 1; t += step) {
			var t1 = (1 - t);
			p = m.applyToPoint(
				t1 * t1 * sx + 2 * t1 * t * cx + t * t * x,
				t1 * t1 * sy + 2 * t1 * t * cy + t * t * y
			);
			path.add(p.x, p.y)
		}

		p = m.applyToPoint(x, y);
		path.add(p.x, p.y);

		this.cx = x;
		this.cy = y
	},

	bezierCurveTo: function(cx1, cy1, cx2, cy2, x, y) {

		var path = this.paths[this.cp],
			l = path.points.length,
			sx = l > 1 ? this.cx : cx1,
			sy = l > 1 ? this.cy : cy1,
			step = this.step,
			m = this.matrix, p,
			t = step, tm1, tm12, tmm23;

		// B(t) = (1-t)^3 * z0 + 3t (1-t)^2 * c0 + 3 t^2 (1-t) * c1 + t^3 * z1   for 0 <= t <= 1
		for(; t < 1; t += step) {
			tm1 = 1 - t;				// (1 - t)
			tm12 = tm1 * tm1;			// (1 - t) ^ 2
			tmm23 = t * t * 3 * tm1;	// t ^ 2 * 3 * (1 - t)

			p = m.applyToPoint(
				tm12 * tm1 * sx + t * 3 * tm12 * cx1 + tmm23 * cx2 + t * t * t * x,
				tm12 * tm1 * sy + t * 3 * tm12 * cy1 + tmm23 * cy2 + t * t * t * y
			);
			path.add(p.x, p.y)
		}

		p = m.applyToPoint(x, y);
		path.add(p.x, p.y);

		this.cx = x;
		this.cy = y
	}
};
/*
	8-bit Path object used internally in Path2D
	� 2016 Epistemex
	www.epistemex.com
*/

/**
 * Local Path object to hold points for each sub-path
 * @constructor
 * @private
 */
_8bit.Path2D.Path = function(path) {
	this.points = path ? path.concat() : [];
	this.isClosed = false;
};

_8bit.Path2D.Path.prototype = {
	add: function(x, y) {this.points.push(x, y)},   // NOTE: rounded to integer happens via the matrix !
	concat: function(a) {this.points = this.points.concat(a)}
};

/*
	Stripped down version of the Matrix (v2.3.2 MODIFIED). See original:
	https://github.com/epistemex/transformation-matrix-js
*/

/**
 * 2D transformation _8bit.Matrix object initialized with identity _8bit.Matrix.
 *
 * The _8bit.Matrix can synchronize a canvas 2D context by supplying the context
 * as an argument, or later apply current absolute transform to an
 * existing context.
 *
 * To synchronize a DOM element you can use [`toCSS()`]{@link _8bit.Matrix#toCSS} or [`toCSS3D()`]{@link _8bit.Matrix#toCSS3D}.
 *
 * @param {CanvasRenderingContext2D} [context] - Optional context to sync with _8bit.Matrix
 * @prop {number} a - scale x
 * @prop {number} b - shear y
 * @prop {number} c - shear x
 * @prop {number} d - scale y
 * @prop {number} e - translate x
 * @prop {number} f - translate y
 * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
 * @constructor
 * @license MIT license (header required)
 * @copyright Epistemex.com 2014-2016
 */
_8bit.Matrix = function(context) {

	var me = this;
	me._t = me.transform;

	me.a = me.d = 1;
	me.b = me.c = me.e = me.f = 0;

	// reset canvas to enable 100% sync.
	if (context)
		(me.context = context).setTransform(1, 0, 0, 1, 0, 0);
};

/**
 * Create a new _8bit.Matrix from a SVGCanvas8BitContext.Matrix
 *
 * @param {SVGMatrix} svgMatrix - source SVG _8bit.Matrix
 * @param {CanvasRenderingContext2D} [context] - optional canvas 2D context to use for the _8bit.Matrix
 * @returns {_8bit.Matrix}
 * @static
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGCanvas8BitContext.Matrix|MDN / SVGCanvas8BitContext.Matrix}
 */
_8bit.Matrix.fromSVGMatrix = function(svgMatrix, context) {
	return new _8bit.Matrix(context).multiply(svgCanvas8BitContext.Matrix)
};

/**
 * Create and transform a new _8bit.Matrix based on given _8bit.Matrix values.
 *
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @param {number} d
 * @param {number} e
 * @param {number} f
 * @param {CanvasRenderingContext2D} [context] - optional canvas context to synchronize
 * @returns {_8bit.Matrix}
 * @static
 */
_8bit.Matrix.from = function(a, b, c, d, e, f, context) {
	return new _8bit.Matrix(context).setTransform(a, b, c, d, e, f)
};

_8bit.Matrix.prototype = {

	/**
	 * Concatenates transforms of this _8bit.Matrix onto the given child _8bit.Matrix and
	 * returns a new _8bit.Matrix. This instance is used on left side.
	 *
	 * @param {_8bit.Matrix|SVGCanvas8BitContext.Matrix} cm - child _8bit.Matrix to apply concatenation to
	 * @returns {_8bit.Matrix} - new _8bit.Matrix instance
	 */
	concat: function(cm) {
		return this.clone().multiply(cm)
	},

	/**
	 * Flips the horizontal values.
	 * @returns {_8bit.Matrix}
	 */
	flipX: function() {
		return this._t(-1, 0, 0, 1, 0, 0)
	},

	/**
	 * Flips the vertical values.
	 * @returns {_8bit.Matrix}
	 */
	flipY: function() {
		return this._t(1, 0, 0, -1, 0, 0)
	},

	/**
	 * Reflects incoming (velocity) vector on the normal which will be the
	 * current transformed x axis. Call when a trigger condition is met.
	 *
	 * @param {number} x - vector end point for x (start = 0)
	 * @param {number} y - vector end point for y (start = 0)
	 * @returns {{x: number, y: number}}
	 */
	reflectVector: function(x, y) {

		var v = this.applyToPoint(0, 1),
			d = (v.x * x + v.y * y) * 2;

		x -= d * v.x;
		y -= d * v.y;

		return {x: x, y: y}
	},

	/**
	 * Short-hand to reset current _8bit.Matrix to an identity _8bit.Matrix.
	 * @returns {_8bit.Matrix}
	 */
	reset: function() {
		return this.setTransform(1, 0, 0, 1, 0, 0)
	},

	/**
	 * Rotates current _8bit.Matrix by angle (accumulative).
	 * @param {number} angle - angle in radians
	 * @returns {_8bit.Matrix}
	 */
	rotate: function(angle) {
		var cos = Math.cos(angle),
			sin = Math.sin(angle);
		return this._t(cos, sin, -sin, cos, 0, 0)
	},

	/**
	 * Converts a vector given as `x` and `y` to angle, and
	 * rotates (accumulative).
	 * @param x
	 * @param y
	 * @returns {_8bit.Matrix}
	 */
	rotateFromVector: function(x, y) {
		return this.rotate(Math.atan2(y, x))
	},

	/**
	 * Helper method to make a rotation based on an angle in degrees.
	 * @param {number} angle - angle in degrees
	 * @returns {_8bit.Matrix}
	 */
	rotateDeg: function(angle) {
		return this.rotate(angle * Math.PI / 180)
	},

	/**
	 * Scales current _8bit.Matrix uniformly and accumulative.
	 * @param {number} f - scale factor for both x and y (1 does nothing)
	 * @returns {_8bit.Matrix}
	 */
	scaleU: function(f) {
		return this._t(f, 0, 0, f, 0, 0)
	},

	/**
	 * Scales current _8bit.Matrix accumulative.
	 * @param {number} sx - scale factor x (1 does nothing)
	 * @param {number} sy - scale factor y (1 does nothing)
	 * @returns {_8bit.Matrix}
	 */
	scale: function(sx, sy) {
		return this._t(sx, 0, 0, sy, 0, 0)
	},

	/**
	 * Scales current _8bit.Matrix on x axis accumulative.
	 * @param {number} sx - scale factor x (1 does nothing)
	 * @returns {_8bit.Matrix}
	 */
	scaleX: function(sx) {
		return this._t(sx, 0, 0, 1, 0, 0)
	},

	/**
	 * Scales current _8bit.Matrix on y axis accumulative.
	 * @param {number} sy - scale factor y (1 does nothing)
	 * @returns {_8bit.Matrix}
	 */
	scaleY: function(sy) {
		return this._t(1, 0, 0, sy, 0, 0)
	},

	/**
	 * Apply shear to the current _8bit.Matrix accumulative.
	 * @param {number} sx - amount of shear for x
	 * @param {number} sy - amount of shear for y
	 * @returns {_8bit.Matrix}
	 */
	shear: function(sx, sy) {
		return this._t(1, sy, sx, 1, 0, 0)
	},

	/**
	 * Apply shear for x to the current _8bit.Matrix accumulative.
	 * @param {number} sx - amount of shear for x
	 * @returns {_8bit.Matrix}
	 */
	shearX: function(sx) {
		return this._t(1, 0, sx, 1, 0, 0)
	},

	/**
	 * Apply shear for y to the current _8bit.Matrix accumulative.
	 * @param {number} sy - amount of shear for y
	 * @returns {_8bit.Matrix}
	 */
	shearY: function(sy) {
		return this._t(1, sy, 0, 1, 0, 0)
	},

	/**
	 * Apply skew to the current _8bit.Matrix accumulative. Angles in radians.
	 * Also see [`skewDeg()`]{@link _8bit.Matrix#skewDeg}.
	 * @param {number} ax - angle of skew for x
	 * @param {number} ay - angle of skew for y
	 * @returns {_8bit.Matrix}
	 */
	skew: function(ax, ay) {
		return this.shear(Math.tan(ax), Math.tan(ay))
	},

	/**
	 * Apply skew to the current _8bit.Matrix accumulative. Angles in degrees.
	 * Also see [`skew()`]{@link _8bit.Matrix#skew}.
	 * @param {number} ax - angle of skew for x
	 * @param {number} ay - angle of skew for y
	 * @returns {_8bit.Matrix}
	 */
	skewDeg: function(ax, ay) {
		return this.shear(Math.tan(ax / 180 * Math.PI), Math.tan(ay / 180 * Math.PI))
	},

	/**
	 * Apply skew for x to the current _8bit.Matrix accumulative. Angles in radians.
	 * Also see [`skewDeg()`]{@link _8bit.Matrix#skewDeg}.
	 * @param {number} ax - angle of skew for x
	 * @returns {_8bit.Matrix}
	 */
	skewX: function(ax) {
		return this.shearX(Math.tan(ax))
	},

	/**
	 * Apply skew for y to the current _8bit.Matrix accumulative. Angles in radians.
	 * Also see [`skewDeg()`]{@link _8bit.Matrix#skewDeg}.
	 * @param {number} ay - angle of skew for y
	 * @returns {_8bit.Matrix}
	 */
	skewY: function(ay) {
		return this.shearY(Math.tan(ay))
	},

	/**
	 * Set current _8bit.Matrix to new absolute _8bit.Matrix.
	 * @param {number} a - scale x
	 * @param {number} b - shear y
	 * @param {number} c - shear x
	 * @param {number} d - scale y
	 * @param {number} e - translate x
	 * @param {number} f - translate y
	 * @returns {_8bit.Matrix}
	 */
	setTransform: function(a, b, c, d, e, f) {
		var me = this;
		me.a = a;
		me.b = b;
		me.c = c;
		me.d = d;
		me.e = e;
		me.f = f;
		return me._x()
	},

	/**
	 * Translate current _8bit.Matrix accumulative.
	 * @param {number} tx - translation for x
	 * @param {number} ty - translation for y
	 * @returns {_8bit.Matrix}
	 */
	translate: function(tx, ty) {
		return this._t(1, 0, 0, 1, tx, ty)
	},

	/**
	 * Translate current _8bit.Matrix on x axis accumulative.
	 * @param {number} tx - translation for x
	 * @returns {_8bit.Matrix}
	 */
	translateX: function(tx) {
		return this._t(1, 0, 0, 1, tx, 0)
	},

	/**
	 * Translate current _8bit.Matrix on y axis accumulative.
	 * @param {number} ty - translation for y
	 * @returns {_8bit.Matrix}
	 */
	translateY: function(ty) {
		return this._t(1, 0, 0, 1, 0, ty)
	},

	/**
	 * Multiplies current _8bit.Matrix with new _8bit.Matrix values. Also see [`multiply()`]{@link _8bit.Matrix#multiply}.
	 *
	 * @param {number} a2 - scale x
	 * @param {number} b2 - shear y
	 * @param {number} c2 - shear x
	 * @param {number} d2 - scale y
	 * @param {number} e2 - translate x
	 * @param {number} f2 - translate y
	 * @returns {_8bit.Matrix}
	 */
	transform: function(a2, b2, c2, d2, e2, f2) {

		var me = this,
			a1 = me.a,
			b1 = me.b,
			c1 = me.c,
			d1 = me.d,
			e1 = me.e,
			f1 = me.f;

		/* _8bit.Matrix order (canvas compatible):
		* ace
		* bdf
		* 001
		*/
		me.a = a1 * a2 + c1 * b2;
		me.b = b1 * a2 + d1 * b2;
		me.c = a1 * c2 + c1 * d2;
		me.d = b1 * c2 + d1 * d2;
		me.e = a1 * e2 + c1 * f2 + e1;
		me.f = b1 * e2 + d1 * f2 + f1;

		return me._x()
	},

	/**
	 * Multiplies current _8bit.Matrix with source _8bit.Matrix.
	 * @param {_8bit.Matrix} m - source _8bit.Matrix to multiply with.
	 * @returns {_8bit.Matrix}
	 */
	multiply: function(m) {
		return this._t(m.a, m.b, m.c, m.d, m.e, m.f)
	},

	/**
	 * Divide this _8bit.Matrix on input _8bit.Matrix which must be invertible.
	 * @param {_8bit.Matrix} m - _8bit.Matrix to divide on (divisor)
	 * @throws Exception is input _8bit.Matrix is not invertible
	 * @returns {_8bit.Matrix}
	 */
	divide: function(m) {

		if (!m.isInvertible())
			throw "_8bit.Matrix not invertible";

		return this.multiply(m.inverse())
	},

	/**
	 * Divide current _8bit.Matrix on scalar value != 0.
	 * @param {number} d - divisor (can not be 0)
	 * @returns {_8bit.Matrix}
	 */
	divideScalar: function(d) {

		var me = this;
		me.a /= d;
		me.b /= d;
		me.c /= d;
		me.d /= d;
		me.e /= d;
		me.f /= d;

		return me._x()
	},

	/**
	 * Get an inverse _8bit.Matrix of current _8bit.Matrix. The method returns a new
	 * _8bit.Matrix with values you need to use to get to an identity _8bit.Matrix.
	 * Context from parent _8bit.Matrix is not applied to the returned _8bit.Matrix.
	 *
	 * @param {boolean} [cloneContext=false] - clone current context to resulting _8bit.Matrix
	 * @throws Exception is input _8bit.Matrix is not invertible
	 * @returns {_8bit.Matrix} - new _8bit.Matrix instance
	 */
	inverse: function(cloneContext) {

		var me = this,
			m  = new _8bit.Matrix(cloneContext ? me.context : null),
			dt = me.determinant();

		if (me._q(dt, 0))
			throw "_8bit.Matrix not invertible.";

		m.a = me.d / dt;
		m.b = -me.b / dt;
		m.c = -me.c / dt;
		m.d = me.a / dt;
		m.e = (me.c * me.f - me.d * me.e) / dt;
		m.f = -(me.a * me.f - me.b * me.e) / dt;

		return m
	},

	/**
	 * Interpolate this _8bit.Matrix with another and produce a new _8bit.Matrix.
	 * `t` is a value in the range [0.0, 1.0] where 0 is this instance and
	 * 1 is equal to the second _8bit.Matrix. The `t` value is not clamped.
	 *
	 * Context from parent _8bit.Matrix is not applied to the returned _8bit.Matrix.
	 *
	 * Note: this interpolation is naive. For animation containing rotation,
	 * shear or skew use the [`interpolateAnim()`]{@link _8bit.Matrix#interpolateAnim} method instead
	 * to avoid unintended flipping.
	 *
	 * @param {_8bit.Matrix} m2 - the _8bit.Matrix to interpolate with.
	 * @param {number} t - interpolation [0.0, 1.0]
	 * @param {CanvasRenderingContext2D} [context] - optional context to affect
	 * @returns {_8bit.Matrix} - new _8bit.Matrix instance with the interpolated result
	 */
	interpolate: function(m2, t, context) {

		var me = this,
			m  = context ? new _8bit.Matrix(context) : new _8bit.Matrix();

		m.a = me.a + (m2.a - me.a) * t;
		m.b = me.b + (m2.b - me.b) * t;
		m.c = me.c + (m2.c - me.c) * t;
		m.d = me.d + (m2.d - me.d) * t;
		m.e = me.e + (m2.e - me.e) * t;
		m.f = me.f + (m2.f - me.f) * t;

		return m._x()
	},

	/**
	 * Interpolate this _8bit.Matrix with another and produce a new _8bit.Matrix.
	 * `t` is a value in the range [0.0, 1.0] where 0 is this instance and
	 * 1 is equal to the second _8bit.Matrix. The `t` value is not constrained.
	 *
	 * Context from parent _8bit.Matrix is not applied to the returned _8bit.Matrix.
	 *
	 * To obtain easing `t` can be preprocessed using easing-functions
	 * before being passed to this method.
	 *
	 * Note: this interpolation method uses decomposition which makes
	 * it suitable for animations (in particular where rotation takes
	 * places).
	 *
	 * @param {_8bit.Matrix} m2 - the _8bit.Matrix to interpolate with.
	 * @param {number} t - interpolation [0.0, 1.0]
	 * @param {CanvasRenderingContext2D} [context] - optional context to affect
	 * @returns {_8bit.Matrix} - new _8bit.Matrix instance with the interpolated result
	 */
	interpolateAnim: function(m2, t, context) {

		var m          = new _8bit.Matrix(context ? context : null),
			d1         = this.decompose(),
			d2         = m2.decompose(),
			t1         = d1.translate,
			t2         = d2.translate,
			s1         = d1.scale,
			rotation   = d1.rotation + (d2.rotation - d1.rotation) * t,
			translateX = t1.x + (t2.x - t1.x) * t,
			translateY = t1.y + (t2.y - t1.y) * t,
			scaleX     = s1.x + (d2.scale.x - s1.x) * t,
			scaleY     = s1.y + (d2.scale.y - s1.y) * t
			;

		// QR order (t-r-s-sk)
		m.translate(translateX, translateY);
		m.rotate(rotation);
		m.scale(scaleX, scaleY);
		//todo test skew scenarios

		return m._x()
	},

	/**
	 * Decompose the current _8bit.Matrix into simple transforms using either
	 * QR (default) or LU decomposition.
	 *
	 * @param {boolean} [useLU=false] - set to true to use LU rather than QR decomposition
	 * @returns {*} - an object containing current decomposed values (translate, rotation, scale, skew)
	 * @see {@link http://www.maths-informatique-jeux.com/blog/frederic/?post/2013/12/01/Decomposition-of-2D-transform-matrices|Adoption based on this code}
	 * @see {@link https://en.wikipedia.org/wiki/QR_decomposition|More on QR decomposition}
	 * @see {@link https://en.wikipedia.org/wiki/LU_decomposition|More on LU decomposition}
	 */
	decompose: function(useLU) {

		var me        = this,
			a         = me.a,
			b         = me.b,
			c         = me.c,
			d         = me.d,
			acos      = Math.acos,
			atan      = Math.atan,
			sqrt      = Math.sqrt,
			pi        = Math.PI,

			translate = {x: me.e, y: me.f},
			rotation  = 0,
			scale     = {x: 1, y: 1},
			skew      = {x: 0, y: 0},

			determ    = a * d - b * c;	// determinant(), skip DRY here...

		if (useLU) {
			if (a) {
				skew = {x: atan(c / a), y: atan(b / a)};
				scale = {x: a, y: determ / a};
			}
			else if (b) {
				rotation = pi * 0.5;
				scale = {x: b, y: determ / b};
				skew.x = atan(d / b);
			}
			else { // a = b = 0
				scale = {x: c, y: d};
				skew.x = pi * 0.25;
			}
		}
		else {
			// Apply the QR-like decomposition.
			if (a || b) {
				var r = sqrt(a * a + b * b);
				rotation = b > 0 ? acos(a / r) : -acos(a / r);
				scale = {x: r, y: determ / r};
				skew.x = atan((a * c + b * d) / (r * r));
			}
			else if (c || d) {
				var s = sqrt(c * c + d * d);
				rotation = pi * 0.5 - (d > 0 ? acos(-c / s) : -acos(c / s));
				scale = {x: determ / s, y: s};
				skew.y = atan((a * c + b * d) / (s * s));
			}
			else { // a = b = c = d = 0
				scale = {x: 0, y: 0};
			}
		}

		return {
			translate: translate,
			rotation : rotation,
			scale    : scale,
			skew     : skew
		}
	},

	/**
	 * Returns the determinant of the current _8bit.Matrix.
	 * @returns {number}
	 */
	determinant: function() {
		return this.a * this.d - this.b * this.c
	},

	/**
	 * Apply current _8bit.Matrix to `x` and `y` of a point.
	 * Returns a point object.
	 *
	 * @param {number} x - value for x
	 * @param {number} y - value for y
	 * @returns {{x: number, y: number}} A new transformed point object
	 */
	applyToPoint: function(x, y) {

		var me = this;

		return {
			x: Math.round(x * me.a + y * me.c + me.e),
			y: Math.round(x * me.b + y * me.d + me.f)
		}
	},

	/**
	 * Apply current _8bit.Matrix to array with point objects or point pairs.
	 * Returns a new array with points in the same format as the input array.
	 *
	 * A point object is an object literal:
	 *
	 *     {x: x, y: y}
	 *
	 * so an array would contain either:
	 *
	 *     [{x: x1, y: y1}, {x: x2, y: y2}, ... {x: xn, y: yn}]
	 *
	 * or
	 *
	 *     [x1, y1, x2, y2, ... xn, yn]
	 *
	 * @param {Array} points - array with point objects or pairs
	 * @returns {Array} A new array with transformed points
	 */
	applyToArray: function(points) {

		var i = 0, p, l,
			mxPoints = [];

		l = points.length;

		if (this.isIdentity()) {
			while(i < l)
				mxPoints.push((points[i++] + 0.5)|0, (points[i++] + 0.5)|0);
		}
		else {
			while(i < l) {
				p = this.applyToPoint(points[i++], points[i++]);
				mxPoints.push((p.x + 0.5)|0, (p.y + 0.5)|0);
			}
		}

		return mxPoints
	},

	/**
	 * Apply to any canvas 2D context object. This does not affect the
	 * context that optionally was referenced in constructor unless it is
	 * the same context.
	 *
	 * @param {CanvasRenderingContext2D} context - target context
	 * @returns {_8bit.Matrix}
	 */
	applyToContext: function(context) {
		var me = this;
		context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);
		return me
	},

	/**
	 * Returns true if _8bit.Matrix is an identity _8bit.Matrix (no transforms applied).
	 * @returns {boolean}
	 */
	isIdentity: function() {
		var me = this;
		return me._q(me.a, 1) &&
			me._q(me.b, 0) &&
			me._q(me.c, 0) &&
			me._q(me.d, 1) &&
			me._q(me.e, 0) &&
			me._q(me.f, 0)
	},

	/**
	 * Returns true if _8bit.Matrix is invertible
	 * @returns {boolean}
	 */
	isInvertible: function() {
		return !this._q(this.determinant(), 0)
	},

	/**
	 * The method is intended for situations where scale is accumulated
	 * via multiplications, to detect situations where scale becomes
	 * "trapped" with a value of zero. And in which case scale must be
	 * set explicitly to a non-zero value.
	 *
	 * @returns {boolean}
	 */
	isValid: function() {
		return !(this.a * this.d)
	},

	/**
	 * Compares current _8bit.Matrix with another _8bit.Matrix. Returns true if equal
	 * (within epsilon tolerance).
	 * @param {_8bit.Matrix} m - _8bit.Matrix to compare this _8bit.Matrix with
	 * @returns {boolean}
	 */
	isEqual: function(m) {

		var me = this,
			q = me._q;

		return  q(me.a, m.a) &&
				q(me.b, m.b) &&
				q(me.c, m.c) &&
				q(me.d, m.d) &&
				q(me.e, m.e) &&
				q(me.f, m.f)
	},

	/**
	 * Clones current instance and returning a new _8bit.Matrix.
	 * @param {_8bit.Matrix} [s] - source matrix
	 * @returns {_8bit.Matrix} - a new _8bit.Matrix instance with identical transformations as this instance
	 */
	clone: function(s) {
		if (s) {	// specially for 8bit
			this.a = s.a;
			this.b = s.b;
			this.c = s.c;
			this.d = s.d;
			this.e = s.e;
			this.f = s.f;
		}
		else
			return new _8bit.Matrix().multiply(this)
	},

	/**
	 * Returns an array with current _8bit.Matrix values.
	 * @returns {Array}
	 */
	toArray: function() {
		var me = this;
		return [me.a, me.b, me.c, me.d, me.e, me.f]
	},

	/**
	 * Returns a binary typed array, either as 32-bit (default) or
	 * 64-bit.
	 * @param {boolean} [use64=false] chose whether to use 32-bit or 64-bit typed array
	 * @returns {*}
	 */
	toTypedArray: function(use64) {

		var a  = use64 ? new Float64Array(6) : new Float32Array(6),
			me = this;

		a[0] = me.a;
		a[1] = me.b;
		a[2] = me.c;
		a[3] = me.d;
		a[4] = me.e;
		a[5] = me.f;

		return a
	},

	/**
	 * Generates a string that can be used with CSS `transform`.
	 * @example
	 *     element.style.transform = m.toCSS();
	 * @returns {string}
	 */
	toCSS: function() {
		return "_8bit.Matrix(" + this.toArray() + ")"
	},

	/**
	 * Generates a `_8bit.Matrix3d()` string that can be used with CSS `transform`.
	 * Although the _8bit.Matrix is for 2D use you may see performance benefits
	 * on some devices using a 3D CSS transform instead of a 2D.
	 * @example
	 *     element.style.transform = m.toCSS3D();
	 * @returns {string}
	 */
	toCSS3D: function() {
		var me = this;
		return "_8bit.Matrix3d(" + me.a + "," + me.b + ",0,0," + me.c + "," + me.d + ",0,0,0,0,1,0," + me.e + "," + me.f + ",0,1)"
	},

	/**
	 * Returns a JSON compatible string of current _8bit.Matrix.
	 * @returns {string}
	 */
	toJSON: function() {
		var me = this;
		return '{"a":' + me.a + ',"b":' + me.b + ',"c":' + me.c + ',"d":' + me.d + ',"e":' + me.e + ',"f":' + me.f + '}'
	},

	/**
	 * Returns a string with current _8bit.Matrix as comma-separated list.
	 * @param {number} [fixLen=4] - truncate decimal values to number of digits
	 * @returns {string}
	 */
	toString: function(fixLen) {
		var me = this;
		fixLen = fixLen || 4;
		return 	 "a=" + me.a.toFixed(fixLen) +
				" b=" + me.b.toFixed(fixLen) +
				" c=" + me.c.toFixed(fixLen) +
				" d=" + me.d.toFixed(fixLen) +
				" e=" + me.e.toFixed(fixLen) +
				" f=" + me.f.toFixed(fixLen)
	},

	/**
	 * Compares floating point values with some tolerance (epsilon)
	 * @param {number} f1 - float 1
	 * @param {number} f2 - float 2
	 * @returns {boolean}
	 * @private
	 */
	_q: function(f1, f2) {
		return Math.abs(f1 - f2) < 1e-14
	},

	/**
	 * Apply current absolute _8bit.Matrix to context if defined, to sync it.
	 * @returns {_8bit.Matrix}
	 * @private
	 */
	_x: function() {
		var me = this;
		if (me.context)
			me.context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);
		return me
	}
};
/*
	8-bit Image

	� 2016 Epistemex
	www.epistemex.com
	MIT License
*/

_8bit.Image = function(w, h, ctx) {

	var me = this,
		img = new Image;

	this.onload = null;
	this.onerror = null;
	this.bitmap = null;
	this.width = 0;
	this.height = 0;
	this.naturalWidth = 0;
	this.naturalHeight = 0;
	this.palette = ctx.palette;

	img.onload = function(e) {

		me.width = me.naturalWidth = w = w ? w : img.naturalWidth || img.width;
		me.height = me.naturalHeight = h = h ? h : img.naturalHeight || img.height;
		me.bitmap = _8bit.Image.convert(img, w, h, ctx);

		if (me.onload) (me.onload.bind(me))(e);
	};

	img.onerror = function(e) {
		if (me.onerror) (me.onerror.bind(me))(e);
	};

	img.onabort = function(e) {
		if (me.onabort) me.onabort(e);
	};

	Object.defineProperty(this, "src", {
		get: function() {return img.src},
		set: function(v) {
			img.src = v
		}
	});

	Object.defineProperty(this, "crossOrigin", {
		get: function() {return img.crossOrigin},
		set: function(v) {
			img.crossOrigin = v
		}
	});
};

_8bit.Image.convert = function(img, w, h, ctx8) {

	// todo optimize by working directly with buffer one iteration and with inline calculations

	var ctx = _8bit.utils.getContext(w, h),
		idata, buffer, buffer32, len,
		cols = [],
		ditherMode,
		x, y,
		p, yc, nc,
		dither,
		palette = ctx8.palette,
		mode = ctx8.imageSmoothingQuality,
		i = 0,
		funcs = [ditherOrdered, ditherSierra, ditherFloydSteinberg],
		bayer = [
			0.0176,0.1588,0.0530,0.1941,
			0.2294,0.0882,0.2647,0.1235,
			0.0706,0.2118,0.0353,0.1765,
			0.2824,0.1412,0.2471,0.1059];

	// low=no dithering, medium=sierra, high=floyd-steinberg
	ditherMode = ["low", "medium", "high"].indexOf(mode);

	ctx.drawImage(img, 0, 0, w, h);
	idata = ctx.getImageData(0, 0, w, h);
	buffer = idata.data;
	len = buffer.length;

	buffer32 = new Uint32Array(idata.data.buffer);

	if (!ctx8.imageSmoothingEnabled || ditherMode < 0) {

		while(i < len) {
			buffer32[i++] = palette.getNearestColor(new _8bit.Color(buffer32[i])).int32
		}
	}
	else {

		// convert pixels to Color classes
		for(y = 0; y < h; y++) {

			cols.push([]);

			for(x = 0, yc = cols[y]; x < w; x++) {
				p = y * w + x;
				yc.push(new _8bit.Color(buffer32[p]));
			}
		}

		dither = funcs[ditherMode];

		for(y = 0, p = 0; y < h; y++) {
			for(x = 0; x < w; x++) {
				nc = dither(cols, palette, x, y, w, h);
				buffer32[p++] = nc.int32;
			}
		}

	}

	function ditherFloydSteinberg(cols, palette, x, y, w, h) {

		var oc = cols[y][x],
			nc = palette.getNearestColor(oc),
			err = oc.sub(nc),
			xp1 = x + 1,
			y1 = y + 1,
			xm1, colY;

		if (xp1 < w)
			cols[y][xp1] = cols[y][xp1].add(err.mul(0.4375)); 		// 7/16

		if (y1 < h) {
			xm1 = x - 1;
			colY = cols[y1];
			colY[x] = colY[x].add(err.mul(0.3125));					// 5/16

			if (xm1 >= 0)
				colY[xm1] = colY[xm1].add(err.mul(0.1875));			// 3/16

			if (xp1 < w)
				colY[xp1] = colY[xp1].add(err.mul(0.0625));			// 1/16
		}

		return nc
	}

	function ditherSierra(cols, palette, x, y, w, h) {

		var oc = cols[y][x],
			nc = palette.getNearestColor(oc),
			err = oc.sub(nc),
			xp1 = x + 1,
			xm1 = x - 1,
			y1 = y + 1,
			colY = cols[y1];

		if (xp1 < w)
			cols[y][xp1] = cols[y][xp1].add(err.mul(0.5));			// /2

		if (y1 < h) {
			colY[x] = colY[x].add(err.mul(0.25));					// /4

			if (xm1 >= 0)
				colY[xm1] = colY[xm1].add(err.mul(0.25));			// /4
		}

		return nc
	}

	function ditherOrdered(cols, palette, x, y) {

		var oc = cols[y][x],
			t = ((y % 4) << 2) + (x % 4),
			dither = bayer[t];

		return palette.getNearestColor(
			new _8bit.Color(
				oc.r + (oc.r * dither & 0xff),
				oc.g + (oc.g * dither & 0xff),
				oc.b + (oc.b * dither & 0xff)
			))
	}

	return idata
};/*
	8-bit render module
	� 2016 Epistemex
	www.epistemex.com
*/

_8bit.Shaders.Pixelated = function(w, h, noAlpha) {

	var me = this;

	this.ctx = _8bit.utils.getContext(w, h, !!noAlpha);
	this.canvas = this.ctx.canvas;

	this.width = w;
	this.height = h;

	_8bit.utils.disableSmoothing(me.ctx)
};

_8bit.Shaders.Pixelated.prototype = {

	drawToCtx: function(ctx, w, h) {
		if (w && h)
			ctx.drawImage(this.canvas, 0, 0, w, h);
		else
			ctx.drawImage(this.canvas, 0, 0);
	},

	drawToRender: function(r, w, h) {
		this.drawToCtx(r.ctx, w, h)
	},

	clearRect: function(x, y, w, h, state) {

		// Since we don't use alpha, we will fill the background with
		// current "background" color. Apply transforms if any.

		if (state)
			state.matrix.applyToContext(this.ctx);

		this.ctx.fillStyle = state.styles[2].color.toStyle();
		this.ctx.fillRect(x, y, w, h);
		this.ctx.setTransform(1,0,0,1,0,0)
	},

	stroke: function(paths, state, ctx8) {

		// fCol is used only by fill() to force a solid color (not
		// pattern etc.). This outline is used to correct the rounding
		// errors from the two different approaches.

		var w = this.width,
			h = this.height,
			idata = this.ctx.createImageData(w, h),
			bmp = new Uint32Array(idata.data.buffer),
			style = state.styles[0],
			src, func,
			pts, p, i, t;

		switch(style.type) {

			case _8bit.Style.type.solid:	// solid
				src = style.style;
				func = setPixel;
				break;

			case _8bit.Style.type.pattern: // pattern
				src = style.original;
				func = setPixelPG;
				break;

			case _8bit.Style.type.gradient: // gradient
				src = style.original;
				func = setPixelPG;
				src._generate(ctx8);
				break;
		}

		for(i = 0; p = paths[i++];) {
			pts = p.points;
			if (pts.length > 1) {

				for(t = 2; t < pts.length; t += 2)
					line(pts[t-2], pts[t-1], pts[t], pts[t+1]);

				if (p.isClosed)
					line(pts[pts.length - 2], pts[pts.length - 1], pts[0], pts[1]);
			}
		}

		this.ctx.putImageData(idata, 0, 0);


		// helpers ---

		function setPixel(x, y) {
			if (x >= 0 && x < w && y >= 0 && y < h)
				bmp[y * w + x] = src;
		}

		function setPixelPG(x, y) {
			if (x >= 0 && x < w && y >= 0 && y < h)
				bmp[y * w + x] = src._getPixel(x, y);
		}

		function line(x1, y1, x2, y2) {

			var dlt, mul,
				sl = y2 - y1,
				ll = x2 - x1,
				yl = false,
				lls = ll >> 31,
				sls = sl >> 31,
				i;

			if ((sl ^ sls) - sls > (ll ^ lls) - lls) {
				sl ^= ll;
				ll ^= sl;
				sl ^= ll;
				yl = true
			}

			dlt = ll < 0 ? -1 : 1;
			mul = (ll === 0) ? sl : sl / ll;

			if (yl) {
				x1 += 0.5;
				for (i = 0; i !== ll; i += dlt)
					func((x1 + i * mul)|0, y1 + i)
			}
			else {
				y1 += 0.5;
				for (i = 0; i !== ll; i += dlt)
					func(x1 + i, (y1 + i * mul)|0)
			}
		}

	},

	fill: function(paths, state, ctx8, type) {

		var w = this.width,
			h = this.height,
			idata = this.ctx.createImageData(w, h),
			bmp = new Uint32Array(idata.data.buffer),
			style = state.styles[1],
			src, func,
			points, ranges, i;

		switch(style.type) {

			case _8bit.Style.type.solid:	// solid
				src = style.style;
				func = renderSolid;
				break;

			case _8bit.Style.type.pattern: // pattern
				src = style.original;
				func = renderPattGrad;
				break;

			case _8bit.Style.type.gradient: // gradient
				src = style.original;
				func = renderPattGrad;
				src._generate(ctx8);
				break;
		}

		for(i = 0; i < paths.length; i++) {
			points = paths[i].points;
			ranges = getLineRanges(points);
			func(ranges);
		}

		this.ctx.putImageData(idata, 0, 0);

		function renderSolid(ranges) {
			var i = 0, r;
			while(r = ranges[i++]) {
				for(var p, x = Math.max(0, r.x1), y = r.y, x2 = Math.min(w, r.x2); x < x2; x++) {
					p = y * w + x;
					bmp[p] ^= src
				}
			}
		}

		function renderPattGrad(ranges) {
			var i = 0, r, getPixel = src._getPixel;
			while(r = ranges[i++]) {
				for(var p, x = Math.max(0, r.x1), y = r.y, x2 = Math.min(w, r.x2); x < x2; x++) {
					p = y * w + x;
					bmp[p] = bmp[p] ? 0 : getPixel(x, y)
				}
			}
		}

		// get all ranges/segments
		function getLineRanges() {

			var	len = points.length,
				ranges = [],
				pts, pt, y, t;

			for(y = 0.25; y < h; y++) {

				pts = [];

				// find all lines that intersect text line base
				for(t = 0; t < len - 3; t += 2) {
					if ((points[t+1] <= y && points[t+3] >= y) || (points[t+3] <= y && points[t+1] >= y)) {
						pt = getIntersection(-0xffff, y, 0xffff, points[t] + 0.5, points[t+1], points[t+2] + 0.5, points[t+3]);
						if (pt) pts.push(pt)
					}
				}

				// end -> start (fill is always closed)
				pt = getIntersection(-0xffff, y, 0xffff, points[len-2] + 0.5, points[len-1], points[0] + 0.5, points[1]);
				if (pt) pts.push(pt);

				// sort points and create ranges
				if (pts.length > 1) {

					pts.sort(function(a, b) { return a.x - b.x });

					/*
						Check ranges for non-zero winding or even-odd fill
					 */

					// todo non-zero
					// - get center point between two x's
					// - cast ray left and right, count windings and direction
					// - if !0 add to new array
					// ? move this to separate function so it can be embedded in the intersection stage

					// even-odd ranges
					for(t = 0; t < pts.length - 1; t += 2) {
						//if (pts[t] && pts[t+1]) {
							ranges.push({
								x1: Math.max(0, Math.min(w, Math.round(pts[t  ].x) )),
								x2: Math.max(0, Math.min(w, Math.round(pts[t+1].x) )),
								y: pts[t].y|0
							});
						//}
					}
				}
			}

			return ranges
		}

		// note: this is reduced to assume same y for first line
		function getIntersection(p0x, p0y, p1x, p2x, p2y, p3x, p3y) {

			// In our case p2y=p3y would be a parallel line
			if ((p2y|0) === (p3y|0)) return null;

			var	d1x = p1x - p0x,
				d2x = p3x - p2x,
				d2y = p3y - p2y,
				d = d1x * d2y,
				px, py, s, t;

			if (d === 0) return null;

			py = p0y - p2y;
			s = (d1x * py) / d;

			if (s >= 0 && s <= 1) {
				px = p0x - p2x;
				t = (d2x * py - d2y * px) / d;
				if (t >= 0 && t <= 1) {
					return {
						x: p0x + (t * d1x),
						y: p0y
					}
				}
			}

			return null;
		}
	},

	drawImage: function(srcData, state, dx, dy) {

		var w = this.width,
			h = this.height,
			sw = srcData.width,
			sh = srcData.height,
			idata = this.ctx.createImageData(w, h),
			dstBmp = new Uint32Array(idata.data.buffer),
			srcBmp = new Uint32Array(srcData.data.buffer),
			im = state.matrix.inverse(),
			x, y, p, sx, sy;

		if (im.isIdentity()) {

			for(y = 0; y < h; y++) {
				for(x = 0; x < w; x++) {
					sx = x - dx;
					sy = y - dy;
					if (sx >= 0 && sx < sw && sx >= 0 && sy < sh)
						dstBmp[y * w + x] = srcBmp[sy * sw + sx];
				}
			}

		}
		else {
			for(y = 0; y < h; y++) {
				for(x = 0; x < w; x++) {
					p = im.applyToPoint(x, y);
					sx = Math.round(p.x) - dx;
					sy = Math.round(p.y) - dy;
					if (sx >= 0 && sx < sw && sx >= 0 && sy < sh)
						dstBmp[y * w + x] = srcBmp[sy * sw + sx];
				}
			}
		}

		this.ctx.putImageData(idata, 0, 0);
	}

};